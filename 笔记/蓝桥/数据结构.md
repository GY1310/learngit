# 数据结构与算法

### 1.稀疏数组的代码实现

```java
public class SparseArray {
	public static void main(String[] args) {
		/*
		 * 稀疏数组是用来简化数组存放数据的形式
		 * 稀疏数组永远是三列的
		 * 稀疏数组的第一行第一列用来存放原始数组的行数，第二列用来存放原始数组的列数，第三列用来存放非0元素的个数
		 * 稀疏数组的从第二行开始就是第一列存放非0元素的行的位置，第二列用来存放非0元素列的位置，第三列用来存放非0元素的值
		 * 
		 * */
		
		
		// 创建一个原始的二维数组11*11
		// 0表示没有棋子，1表示黑子，2表示白子
		int chessArr1[][] = new int[11][11];
		chessArr1[1][2] = 1;
		chessArr1[2][3] = 2;
		chessArr1[4][6] = 1;
		chessArr1[7][3] = 1;
		// 输出原始的二维数组
		System.out.println("原始的二维数组~");
		for (int[] row : chessArr1) {
			for (int data : row) {
				System.out.printf("%d\t", data);
			}
			System.out.println();
		}

		// 将二维数组转稀疏数组的思想
		// 1.先遍历二维数组 得到非0数据个数
		int sum = 0;
		for (int i = 0; i < 11; i++) {
			for (int j = 0; j < 11; j++) {
				if (chessArr1[j][i] != 0) {
					sum++;
				}
			}
		}
//		System.out.println(sum);

		// 2.创建对应的稀疏数组
		int sparseArr[][] = new int[sum + 1][3];
		// 给稀疏数组赋值
		sparseArr[0][0] = 11;
		sparseArr[0][1] = 11;
		sparseArr[0][2] = sum;

		// 遍历二维数组，将非0的值存放到稀疏数组sparseArr里面去
		int count = 0;// count用于记录第几个非0数据
		for (int i = 0; i < 11; i++) {
			for (int j = 0; j < 11; j++) {
				if (chessArr1[i][j] != 0) {
					count++;
					sparseArr[count][0] = i;
					sparseArr[count][1] = j;
					sparseArr[count][2] = chessArr1[i][j];
					
				}
			}
		}
		
		//输出稀疏数组的形式
		System.out.println();
		System.out.println("得到的稀疏数组为以下形式");
		for(int i = 0;i<sparseArr.length;i++){
			System.out.printf("%d\t%d\t%d\t\n",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]); 
			
		}
		
		
		
		//将稀疏数组恢复成原始的二维数组
		/*
		 * 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的chessArr2 = [11][11]
		 * 2.在读取稀疏数组后几行数据，并赋值给原始的二维数组即可
		 * 
		 * */
		
		//1.先读取稀疏数组的地上传，根据第一行的数据，创建原始的二维数组
		int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
		
		//2.在读取稀疏数组后几行数据，并赋值给原始的二维数组即可
		for(int i =1;i<sparseArr.length;i++){
			chessArr2[sparseArr[i][0]][sparseArr[i][1]]=sparseArr[i][2];
		}
		
		//输出恢复后的二维数组
		System.out.println();
		System.out.println("恢复后的二维数组");
		for(int row[]:chessArr2){
			for(int data:row){
				System.out.printf("%d\t",data);
			}
			System.out.println();
		}
		

	}

}

```



### 2.使用数组模拟队列

```java
import java.util.Scanner;

public class ArrayQueueDemo {
	public static void main(String[] arsgs) {

		// 测试一把
		// 创建一个队列
		ArrayQueue queue = new ArrayQueue(3);
		char key = ' ';// 接收用户输入
		Scanner scanner = new Scanner(System.in);
		boolean loop = true;
		// 输出一个菜单
		while (loop) {
			System.out.println("s(show):显示队列");
			System.out.println("e(exit):退出程序");
			System.out.println("a(add):添加数据到队列");
			System.out.println("g(get):从队列取出数据");
			System.out.println("h(head):查看队列头的数据");
			key = scanner.next().charAt(0);
			switch (key) {
			case 's':// 查看数据
				queue.showQueue();
				break;
			case 'a':// 添加数据
				System.out.println("请输入一个数字");
				int value = scanner.nextInt();
				queue.addQueue(value);
				break;
			case 'g':// 取出数据
				try {
					int res = queue.getQueue();
					System.out.printf("取出的数据是%d\n", res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
				break;
			case 'h':// 查看队列头数据
				try {
					int res = queue.headQueue();
					System.out.printf("队列头的数据是%d\n", res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
				break;
			case 'e':// 退出
				scanner.close();
				loop = false;
				break;

			default:
				break;
			}
		}
		System.out.println("程序退出");
	}
}

// 使用数组模拟队列-编写一个ArrayQueue类
class ArrayQueue {
	private int maxSize;// 表示数组的最大容量
	private int front;// 队列头
	private int rear;// 队列尾
	private int[] arr;// 该数据用于存放数据，模拟队列

	// 创建队列的构造器
	public ArrayQueue(int arrMaxSize) {
		maxSize = arrMaxSize;
		arr = new int[maxSize];
		front = -1;// 指向队列头，分析出front是指向队列头的前一个位置
		rear = -1;// 指向队列尾，指向队列尾的数据(就是队列最后一个数据)

	}

	// 判断队列是否满
	public boolean isFull() {
		return rear == maxSize - 1;
	}

	// 判断队列是否为空
	public boolean isEmpty() {
		return rear == front;
	}

	// 添加数据到队列
	public void addQueue(int n) {
		// 判断队列是否满
		if (isFull()) {
			System.out.println("队列满，不能够加入数据");
			return;
		}
		rear++;// 让 rear后移
	
		arr[rear] = n;
	}

	// 获取队列的数据
	public int getQueue() {
		// 判断队列是否空
		if (isEmpty()) {
			// 通过抛出异常处理
			throw new RuntimeException("队列为空,不能取数据");

		}
		front++;// front后移
	
		return arr[front];

	}

	// 显示队列的所有数据
	public void showQueue() {
		// 遍历
		if (isEmpty()) {
			System.out.println("队列为空，没有数据");
			return;
		}
		for (int i = 0; i < arr.length; i++) {
			System.out.printf("arr[%d]=%d\n", i, arr[i]);
		}

	}

	// 显示队列的头数据，注意不是取出数据
	public int headQueue() {
		// 判断
		if (isEmpty()) {
			throw new RuntimeException("队列为空，没有数据");
		}
		return arr[front + 1];
	}

}


```



### 3.使用数组模拟环形队列

```java
import java.util.Scanner;

/*
 * 思路如下：
 *  1.front变量的含义作一个调整，front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素		front的初始值为=0
 *  2.rear变量的含义作一个调整，rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定			rear的初始值为=0
 * 	3.当队列满时，条件是(rear+1)%maxSize=front 【满】
 *  4.当队列为空时，条件是rear==font 【空】
 * 	5.当我们这样分析，队列中有效的数据个数(rear+maxSize-front)%maxSize    //	rear=1 	font=0
 * 	6.我们就可以在原来的队列上进行修改，得到一个环形队列
 *  
 * */

public class CircleArrayQueueDemo {
	public static void main(String[] args) {
		// 测试一把
		// 创建一个队列
		CircleArray queue = new CircleArray(4);// 说明:设置4其队列有效数据最大为3个
		char key = ' ';// 接收用户输入
		Scanner scanner = new Scanner(System.in);
		boolean loop = true;
		// 输出一个菜单
		while (loop) {
			System.out.println("s(show):显示队列");
			System.out.println("e(exit):退出程序");
			System.out.println("a(add):添加数据到队列");
			System.out.println("g(get):从队列取出数据");
			System.out.println("h(head):查看队列头的数据");
			key = scanner.next().charAt(0);
			switch (key) {
			case 's':// 查看数据
				queue.showQueue();
				break;
			case 'a':// 添加数据
				System.out.println("请输入一个数字");
				int value = scanner.nextInt();
				queue.addQueue(value);
				break;
			case 'g':// 取出数据
				try {
					int res = queue.getQueue();
					System.out.printf("取出的数据是%d\n", res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
				break;
			case 'h':// 查看队列头数据
				try {
					int res = queue.headQueue();
					System.out.printf("队列头的数据是%d\n", res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
				break;
			case 'e':// 退出
				scanner.close();
				loop = false;
				break;

			default:
				break;
			}
		}
		System.out.println("程序退出");

	}

}

class CircleArray {
	private int maxSize;// 表示数组的最大容量
	// front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素
	// front的初始值为=0
	private int front;
	// rear指向队列的最后一个元素的后一个位置，因为希望空出一个空间作为约定
	// rear的初始值为=0
	private int rear;
	private int[] arr;// 该数据用于存放数据，模拟队列

	public CircleArray(int arrMaxSize) {
		maxSize = arrMaxSize;
		arr = new int[maxSize];
		front = 0;
		rear = 0;

	}

	// 判断队列是否满
	public boolean isFull() {
		return (rear + 1) % maxSize == front;
	}

	// 判断是否为空
	public boolean isEmpty() {
		return rear == front;
	}

	// 添加数据到队列
	public void addQueue(int n) {
		// 判断队列是否满
		if (isFull()) {
			System.out.println("队列满，不能够加入数据");
			return;
		}
		// 直接将数据加入
		arr[rear] = n;
		// 将rear后移，这里必须考虑取模
		rear = (rear + 1) % maxSize;
	}

	// 获取队列的数据，出队列
	public int getQueue() {
		// 判断队列是否空
		if (isEmpty()) {
			// 通过抛出异常处理
			throw new RuntimeException("队列为空,不能取数据");

		}
		// 这里需要分析出font是指向队列的第一个元素
		// 1.先把front对应的值保存到一个临时变量
		// 2.将front后移
		// 3.将临时保存的变量返回
		int value = arr[front];
		front = (front + 1) % maxSize;
		return value;

	}

	// 显示队列的所有数据
	public void showQueue() {
		// 遍历
		if (isEmpty()) {
			System.out.println("队列为空，没有数据");
			return;
		}
		// 思路从front开始遍历，遍历多少个元素
		for (int i = front; i < front + size(); i++) {
			System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
			// 为什么(i%maxSize)，因为不一定是i，还可能超过这个数组的大小，所以要取模
		}

	}

	// 求出当前队列有效数据个数
	public int size() {
		/*
		 * rear=1 front=0 maxSize=3
		 */
		return (rear + maxSize - front) % maxSize;
	}

	// 显示队列的头数据，注意不是取出数据
	public int headQueue() {
		// 判断
		if (isEmpty()) {
			throw new RuntimeException("队列为空，没有数据");
		}
		return arr[front];
	}

}

```



### 4.单向链表的创建和遍历

```java
/*
	添加(创建)
	1.先创建一个head头节点，作用就是表示单链表的头
	2.后面我们每添加一个节点，就直接加入到链表的最后
	遍历:
	1.通过一个辅助遍历，帮助遍历整个链表
*/

public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(1, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(2, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(3, "吴用", "智多星");
		HeroNode h4 = new HeroNode(4, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();
		// 加入
		
		singleLinkedList.add(h1);
		singleLinkedList.add(h2);
		singleLinkedList.add(h3);
		singleLinkedList.add(h4);

		// 显示
		singleLinkedList.list();
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="+ nickname + "]";
	}

	// 为了显示方法，我们重写toString方法

}

```



### 5.单向链表按顺序插入节点

```java
/*
	需要按照编号顺序的添加
	1.首先找到新添加的节点的位置，是通过辅助变量(指针),通过遍历来搞定
	2.新的节点.next=temp.next
    3.将temp.next=新的节点
*/

public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(3, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(1, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(4, "吴用", "智多星");
		HeroNode h4 = new HeroNode(2, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();

		// 加入
		singleLinkedList.addByOrder(h1);
		singleLinkedList.addByOrder(h2);
		singleLinkedList.addByOrder(h3);
		singleLinkedList.addByOrder(h4);

		// 显示
		singleLinkedList.list();
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置
	// 将最后这个节点的next 指向新的节点
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// flag标志添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp已经在链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;

			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历链表

		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄%d已经存在了，不能加入\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}

	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

    // 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

	

}

```



### 6.单向链表节点的修改

```java
/*
	需要按照编号顺序的添加
	1.首先找到新添加的节点的位置，是通过辅助变量(指针),通过遍历来搞定
	2.新的节点.next=temp.next
    3.将temp.next=新的节点
*/

public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(3, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(1, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(4, "吴用", "智多星");
		HeroNode h4 = new HeroNode(2, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();

		// 加入
		singleLinkedList.addByOrder(h1);
		singleLinkedList.addByOrder(h2);
		singleLinkedList.addByOrder(h3);
		singleLinkedList.addByOrder(h4);

		// 显示
		singleLinkedList.list();

		// 修改
		HeroNode h5 = new HeroNode(1, "小卢", "玉麒麟~");
		singleLinkedList.update(h5);

		// 显示修改过后的结果
		singleLinkedList.list();
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置
	// 将最后这个节点的next 指向新的节点
	//
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// flag标志添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp已经在链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;

			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历链表

		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄%d已经存在了，不能加入\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}

	}

	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 说明:
	// 1.根据newHeroNode的no来修改
	public void update(HeroNode newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false;// 表示是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 已经遍历完链表了
			}
			if (temp.no == newHeroNode.no) {
				// 找到了
				flag = true;
				break;
			}
			temp = temp.next;

		}
		// 根据flag判断是否找到
		if (flag == true) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {// 没有找到
			System.out.printf("没有找到编号%d的节点，不能修改\n", newHeroNode.no);

		}
	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	// 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

}

```



### 7.单向链表节点的删除

```java
/*
	从单向链表中删除一个节点的思路
	1.我们先找到需要删除的这个节点的前一个节点temp
	2.temp.next=temp.next.next;
	3.被删除的节点，将不会有其它引用指向，会被垃圾回收机制所回收
*/
public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(3, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(1, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(4, "吴用", "智多星");
		HeroNode h4 = new HeroNode(2, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();

		// 加入
		singleLinkedList.addByOrder(h1);
		singleLinkedList.addByOrder(h2);
		singleLinkedList.addByOrder(h3);
		singleLinkedList.addByOrder(h4);

		// 显示
		singleLinkedList.list();

		// 删除
		singleLinkedList.del(1);
		singleLinkedList.del(4);
		singleLinkedList.del(2);
		singleLinkedList.del(3);

		// 显示修改过后的结果
		singleLinkedList.list();
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 
	 1.找到当前链表的最后节点 
	 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置
	// 将最后这个节点的next 指向新的节点
	//
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// flag标志添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp已经在链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;

			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历链表

		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄%d已经存在了，不能加入\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}

	}

	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 说明:
	// 1.根据newHeroNode的no来修改
	public void update(HeroNode newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false;// 表示是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 已经遍历完链表了
			}
			if (temp.no == newHeroNode.no) {
				// 找到了
				flag = true;
				break;
			}
			temp = temp.next;

		}
		// 根据flag判断是否找到
		if (flag == true) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {// 没有找到
			System.out.printf("没有找到编号%d的节点，不能修改\n", newHeroNode.no);

		}
	}

	// 删除节点
	// 思路
	// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
	// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较
	public void del(int no) {
		HeroNode temp = head;
		boolean flag = false;// 标志是否站到待删除节点的前一个节点
		while (true) {
			if (temp.next == null) {
				break;
			}
			if (temp.next.no == no) {
				flag = true;
				break;
			}
			temp = temp.next;// temp后移，遍历
		}

		// 判断flag
		if (flag) {// 找到
			// 可以删除
			temp.next = temp.next.next;
		} else {
			System.out.printf("要删除的%d节点不存在", no);
		}

	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	// 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

}

```



### 8.单向链表有效节点的个数

```java
public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(3, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(1, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(4, "吴用", "智多星");
		HeroNode h4 = new HeroNode(2, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();

		// 加入
		singleLinkedList.addByOrder(h1);
		singleLinkedList.addByOrder(h2);
		singleLinkedList.addByOrder(h3);
		singleLinkedList.addByOrder(h4);

		// 显示
		singleLinkedList.list();

		// 输出有效节点的个数
		System.out.println("有效节点的个数=" + getLength(singleLinkedList.getHead()));

	}

	// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)
	/**
	 * @param head
	 *            链表的头节点
	 * @return 返回的就是有效节点的个数
	 */
	public static int getLength(HeroNode head) {
		if (head.next == null) {
			return 0;
		}
		int length = 0;
		HeroNode cur = head.next;
		while (cur != null) {
			length++;
			cur = cur.next;
		}
		return length;
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	// 返回头节点
	public HeroNode getHead() {
		return head;
	}

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置
	// 将最后这个节点的next 指向新的节点
	//
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// flag标志添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp已经在链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;

			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历链表

		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄%d已经存在了，不能加入\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}

	}

	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 说明:
	// 1.根据newHeroNode的no来修改
	public void update(HeroNode newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false;// 表示是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 已经遍历完链表了
			}
			if (temp.no == newHeroNode.no) {
				// 找到了
				flag = true;
				break;
			}
			temp = temp.next;

		}
		// 根据flag判断是否找到
		if (flag == true) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {// 没有找到
			System.out.printf("没有找到编号%d的节点，不能修改\n", newHeroNode.no);

		}
	}

	// 删除节点
	// 思路
	// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
	// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较
	public void del(int no) {
		HeroNode temp = head;
		boolean flag = false;// 标志是否站到待删除节点的前一个节点
		while (true) {
			if (temp.next == null) {
				break;
			}
			if (temp.next.no == no) {
				flag = true;
				break;
			}
			temp = temp.next;// temp后移，遍历
		}

		// 判断flag
		if (flag) {// 找到
			// 可以删除
			temp.next = temp.next.next;
		} else {
			System.out.printf("要删除的%d节点不存在", no);
		}

	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	// 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

}

```



### 9.查找单向链表中的倒数第K个节点【新浪】

```java
public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(3, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(1, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(4, "吴用", "智多星");
		HeroNode h4 = new HeroNode(2, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();

		// 加入
		singleLinkedList.addByOrder(h1);
		singleLinkedList.addByOrder(h2);
		singleLinkedList.addByOrder(h3);
		singleLinkedList.addByOrder(h4);

		// 显示
		singleLinkedList.list();

		// 显示倒数第k个元素
		System.out.println("倒数第7个节点=" + findLastIndexNode(singleLinkedList.getHead(), 7));
		System.out.println("倒数第2个节点=" + findLastIndexNode(singleLinkedList.getHead(), 2));
		

	}

	/*
	 * 查找单向链表中倒数第k个节点【新浪面试题】 思路 1.编写一个方法接收head节点，同时接收一个index
	 * 2.index表示的是倒数第index个节点 3.先把链表从头到尾遍历，得到链表的总长度getLength
	 * 4.得到size之后，我们从链表的第一个开始遍历(size-index)个，就可以得到 5.如果找到了，则返回该节点，否则返回null
	 */
	public static HeroNode findLastIndexNode(HeroNode head, int index) {
		// 判断如果链表为空，直接返回null
		if (head.next == null) {
			return null;
		}
		// 第一次遍历得到链表的长度(节点个数)
		int size = getLength(head);
		// 第二次遍历 size-index 位置，就是我们倒数第k个节点
		// 先做一个index校验
		if (index <= 0 || index > size) {
			return null;
		}
		// 定义一个辅助变量,for循环定位到倒数的index
		HeroNode cur = head.next;
		for (int i = 0; i < (size - index); i++) {
			cur = cur.next;
		}
		return cur;

	}

	// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)
	/**
	 * @param head
	 *            链表的头节点
	 * @return 返回的就是有效节点的个数
	 */
	public static int getLength(HeroNode head) {
		if (head.next == null) {
			return 0;
		}
		int length = 0;
		HeroNode cur = head.next;
		while (cur != null) {
			length++;
			cur = cur.next;
		}
		return length;
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	// 返回头节点
	public HeroNode getHead() {
		return head;
	}

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置
	// 将最后这个节点的next 指向新的节点
	//
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// flag标志添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp已经在链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;

			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历链表

		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄%d已经存在了，不能加入\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}

	}

	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 说明:
	// 1.根据newHeroNode的no来修改
	public void update(HeroNode newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false;// 表示是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 已经遍历完链表了
			}
			if (temp.no == newHeroNode.no) {
				// 找到了
				flag = true;
				break;
			}
			temp = temp.next;

		}
		// 根据flag判断是否找到
		if (flag == true) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {// 没有找到
			System.out.printf("没有找到编号%d的节点，不能修改\n", newHeroNode.no);

		}
	}

	// 删除节点
	// 思路
	// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
	// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较
	public void del(int no) {
		HeroNode temp = head;
		boolean flag = false;// 标志是否站到待删除节点的前一个节点
		while (true) {
			if (temp.next == null) {
				break;
			}
			if (temp.next.no == no) {
				flag = true;
				break;
			}
			temp = temp.next;// temp后移，遍历
		}

		// 判断flag
		if (flag) {// 找到
			// 可以删除
			temp.next = temp.next.next;
		} else {
			System.out.printf("要删除的%d节点不存在", no);
		}

	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	// 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

}

```



### 10.单向链表的翻转【腾讯】

```java
/*
	思路
	1.先定义一个节点reverseHead = new HeroNode();
	2.从头到尾遍历原来的链表，每遍历一个节点，，就将其取出，并放在新的链表reverseHead的最前端
	3.原来的链表的head.next = reverseHead.next;
*/


public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(3, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(1, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(4, "吴用", "智多星");
		HeroNode h4 = new HeroNode(2, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();

		// 加入
		singleLinkedList.addByOrder(h1);
		singleLinkedList.addByOrder(h2);
		singleLinkedList.addByOrder(h3);
		singleLinkedList.addByOrder(h4);

		// 显示
		System.out.println("链表原来的样子");
		singleLinkedList.list();

		// 翻转链表
		reverseList(singleLinkedList.getHead());

		// 显示翻转之后的链表
		System.out.println("链表翻转之后的样子");
		singleLinkedList.list();

	}

	// 将单向链表翻转
	public static void reverseList(HeroNode head) {
		// 如果当前链表为空，或者只有一个节点，无需翻转，直接返回
		if (head.next == null || head.next.next == null) {
			return;
		}

		// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表
		HeroNode cur = head.next;
		HeroNode next = null;// 指向当前节点[cur]的下一个节点
		HeroNode reverseHead = new HeroNode(0, "", "");
		// 遍历原来的链表。每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端
		while (cur != null) {
			next = cur.next;// 先暂时保存当前节点的下一个节点，因为后面需要使用
			cur.next = reverseHead.next;// 将cur的下一个节点指向新的链表的第一个元素(不是头元素)
			reverseHead.next = cur; // 将cur连接到新的链表上
			cur = next;// 让cur后移
		}
       	

		// 将head.next 指向 reverseHead.next ,实现单向链表的翻转
		head.next = reverseHead.next;

	}

	/*
	 * 查找单向链表中倒数第k个节点【新浪面试题】 思路 1.编写一个方法接收head节点，同时接收一个index
	 * 2.index表示的是倒数第index个节点 3.先把链表从头到尾遍历，得到链表的总长度getLength
	 * 4.得到size之后，我们从链表的第一个开始遍历(size-index)个，就可以得到 5.如果找到了，则返回该节点，否则返回null
	 */
	public static HeroNode findLastIndexNode(HeroNode head, int index) {
		// 判断如果链表为空，直接返回null
		if (head.next == null) {
			return null;
		}
		// 第一次遍历得到链表的长度(节点个数)
		int size = getLength(head);
		// 第二次遍历 size-index 位置，就是我们倒数第k个节点
		// 先做一个index校验
		if (index <= 0 || index > size) {
			return null;
		}
		// 定义一个辅助变量,for循环定位到倒数的index
		HeroNode cur = head.next;
		for (int i = 0; i < (size - index); i++) {
			cur = cur.next;
		}
		return cur;

	}

	// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)
	/**
	 * @param head
	 *            链表的头节点
	 * @return 返回的就是有效节点的个数
	 */
	public static int getLength(HeroNode head) {
		if (head.next == null) {
			return 0;
		}
		int length = 0;
		HeroNode cur = head.next;
		while (cur != null) {
			length++;
			cur = cur.next;
		}
		return length;
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	// 返回头节点
	public HeroNode getHead() {
		return head;
	}

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置
	// 将最后这个节点的next 指向新的节点
	//
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// flag标志添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp已经在链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;

			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历链表

		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄%d已经存在了，不能加入\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}

	}

	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 说明:
	// 1.根据newHeroNode的no来修改
	public void update(HeroNode newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false;// 表示是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 已经遍历完链表了
			}
			if (temp.no == newHeroNode.no) {
				// 找到了
				flag = true;
				break;
			}
			temp = temp.next;

		}
		// 根据flag判断是否找到
		if (flag == true) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {// 没有找到
			System.out.printf("没有找到编号%d的节点，不能修改\n", newHeroNode.no);

		}
	}

	// 删除节点
	// 思路
	// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
	// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较
	public void del(int no) {
		HeroNode temp = head;
		boolean flag = false;// 标志是否站到待删除节点的前一个节点
		while (true) {
			if (temp.next == null) {
				break;
			}
			if (temp.next.no == no) {
				flag = true;
				break;
			}
			temp = temp.next;// temp后移，遍历
		}

		// 判断flag
		if (flag) {// 找到
			// 可以删除
			temp.next = temp.next.next;
		} else {
			System.out.printf("要删除的%d节点不存在", no);
		}

	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	// 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

}

```



### 11.从尾到头打印单向链表【百度】

```java
/*
	思路
	1.方式1：先将单向链表进行翻转操作，然后在遍历即可，这样做的问题是会破坏原来单向链表的结构，不建议
	2.方式2：可以利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，就是实现了逆序打印
*/
 
import java.util.Stack;

public class SingleLinkedListDemo {

	public static void main(String[] args) {

		// 进行测试
		// 先创建节点
		HeroNode h1 = new HeroNode(3, "宋江", "及时雨");
		HeroNode h2 = new HeroNode(1, "卢俊义", "玉麒麟");
		HeroNode h3 = new HeroNode(4, "吴用", "智多星");
		HeroNode h4 = new HeroNode(2, "林冲", "豹子头");

		// 创建一个链表
		SingleLinkedList singleLinkedList = new SingleLinkedList();

		// 加入
		singleLinkedList.addByOrder(h1);
		singleLinkedList.addByOrder(h2);
		singleLinkedList.addByOrder(h3);
		singleLinkedList.addByOrder(h4);

		// 显示
		System.out.println("链表原来的样子");
		singleLinkedList.list();

		// 逆序打印
		System.out.println("链表逆序打印后的样子，没有改变链表本身的结构");
		reversePrint(singleLinkedList.getHead());

	}

	// 方式2：可以利用栈这个数据结构，将各个节点压入栈中，然后利用栈的先进后出的特点，就是实现了逆序打印
	public static void reversePrint(HeroNode head) {
		if (head.next == null) {
			return;// 空链表，不能打印

		}
		// 创建一个栈，将各个节点压入栈中
		Stack<HeroNode> stack = new Stack<HeroNode>();
		HeroNode cur = head.next;
		while (cur != null) {
			stack.push(cur);
			cur = cur.next;// cur后移，这样就可以压入下一个节点
		}
		// 将栈中的节点进行打印，pop 出栈
		while (stack.size() > 0) {
			System.out.println(stack.pop());// stack 栈 的特点是先进后出
		}

	}

	// 将单向链表翻转
	public static void reverseList(HeroNode head) {
		// 如果当前链表为空，或者只有一个节点，无需翻转，直接返回
		if (head.next == null || head.next.next == null) {
			return;
		}

		// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表
		HeroNode cur = head.next;
		HeroNode next = null;// 指向当前节点[cur]的下一个节点
		HeroNode reverseHead = new HeroNode(0, "", "");
		// 遍历原来的链表。每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端
		while (cur != null) {
			next = cur.next;// 先暂时保存当前节点的下一个节点，因为后面需要使用

			cur.next = reverseHead.next;// 将cur的下一个节点指向新的链表的第一个元素(不是头元素)
			reverseHead.next = cur; // 将cur连接到新的链表上

			cur = next;// 让cur后移
		}

		// 将head.next 指向 reverseHead.next ,实现单向链表的翻转
		head.next = reverseHead.next;

	}

	/*
	 * 查找单向链表中倒数第k个节点【新浪面试题】 思路 1.编写一个方法接收head节点，同时接收一个index
	 * 2.index表示的是倒数第index个节点 3.先把链表从头到尾遍历，得到链表的总长度getLength
	 * 4.得到size之后，我们从链表的第一个开始遍历(size-index)个，就可以得到 5.如果找到了，则返回该节点，否则返回null
	 */
	public static HeroNode findLastIndexNode(HeroNode head, int index) {
		// 判断如果链表为空，直接返回null
		if (head.next == null) {
			return null;
		}
		// 第一次遍历得到链表的长度(节点个数)
		int size = getLength(head);
		// 第二次遍历 size-index 位置，就是我们倒数第k个节点
		// 先做一个index校验
		if (index <= 0 || index > size) {
			return null;
		}
		// 定义一个辅助变量,for循环定位到倒数的index
		HeroNode cur = head.next;
		for (int i = 0; i < (size - index); i++) {
			cur = cur.next;
		}
		return cur;

	}

	// 方法:获取到单向链表的节点的个数(如果是带头节点的链表，需要不统计头节点)
	/**
	 * @param head
	 *            链表的头节点
	 * @return 返回的就是有效节点的个数
	 */
	public static int getLength(HeroNode head) {
		if (head.next == null) {
			return 0;
		}
		int length = 0;
		HeroNode cur = head.next;
		while (cur != null) {
			length++;
			cur = cur.next;
		}
		return length;
	}
}

// 定义SingleLinkedList管理我们的英雄
class SingleLinkedList {
	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode head = new HeroNode(0, "", "");

	// 返回头节点
	public HeroNode getHead() {
		return head;
	}

	/*
	 * 添加节点到单向链表 思路，不考虑编号顺序时 1.找到当前链表的最后节点 2.将这个节点的next指向新的节点
	 */

	public void add(HeroNode heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		temp.next = heroNode;

	}

	// 第二种方式在添加英雄时，根据排名将英雄插入到指定的位置
	// 将最后这个节点的next 指向新的节点
	//
	public void addByOrder(HeroNode heroNode) {
		// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助我们找到添加的位置
		// 因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false;// flag标志添加的编号是否存在，默认为false
		while (true) {
			if (temp.next == null) {// 说明temp已经在链表的最后
				break;
			}
			if (temp.next.no > heroNode.no) {// 位置找到了，就在temp的后面插入
				break;

			} else if (temp.next.no == heroNode.no) {// 说明希望添加的heroNode的编号已经存在
				flag = true; // 说明编号存在
				break;
			}
			temp = temp.next;// 后移，遍历链表

		}
		// 判断flag的值
		if (flag) {// 不能添加，说明编号存在
			System.out.printf("准备插入的英雄%d已经存在了，不能加入\n", heroNode.no);
		} else {
			// 插入到链表中，temp后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}

	}

	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 说明:
	// 1.根据newHeroNode的no来修改
	public void update(HeroNode newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false;// 表示是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 已经遍历完链表了
			}
			if (temp.no == newHeroNode.no) {
				// 找到了
				flag = true;
				break;
			}
			temp = temp.next;

		}
		// 根据flag判断是否找到
		if (flag == true) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {// 没有找到
			System.out.printf("没有找到编号%d的节点，不能修改\n", newHeroNode.no);

		}
	}

	// 删除节点
	// 思路
	// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
	// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较
	public void del(int no) {
		HeroNode temp = head;
		boolean flag = false;// 标志是否站到待删除节点的前一个节点
		while (true) {
			if (temp.next == null) {
				break;
			}
			if (temp.next.no == no) {
				flag = true;
				break;
			}
			temp = temp.next;// temp后移，遍历
		}

		// 判断flag
		if (flag) {// 找到
			// 可以删除
			temp.next = temp.next.next;
		} else {
			System.out.printf("要删除的%d节点不存在", no);
		}

	}

	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode，每一个HeroNode的对象就是一个节点
class HeroNode {
	public int no;
	public String name;
	public String nickname;
	public HeroNode next;// 指向下一个节点

	// 构造器
	public HeroNode(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	// 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

}


```



### 12.双向链表的遍历增、删、改、查

```java
/*
	分析双向链表的遍历、添加、修改、删除的操作思路
	1.遍历 和单向链表一样，只是是可以向前查找也可以向后查找
	2.添加 (默认添加到双向链表的最后)
		(1)先找到双向链表最后的这个节点
		(2)temp.next = newHeroNode
		(3)newHeroNode.pre = temp
	3.修改 思路和原来的单向链表一样
	4.删除
		(1)因为是双向链表，因此，我们可以实现自我删除某个节点
		(2)直接找到要删除的这个节点，比如temp
		(3)temp.pre.next = temp.next
		(4)temp.next.pre = temp.pre
*/


 
public class DoubleLinkedListDemo {
	public static void main(String[] args) {

		// 测试
		System.out.println("双向链表的测试");

		HeroNode2 h1 = new HeroNode2(1, "宋江", "及时雨");
		HeroNode2 h2 = new HeroNode2(2, "卢俊义", "玉麒麟");
		HeroNode2 h3 = new HeroNode2(3, "吴用", "智多星");
		HeroNode2 h4 = new HeroNode2(4, "林冲", "豹子头");

		// 创建双向链表
		DoubleLinkedList doubleLinkedList = new DoubleLinkedList();

		// 将节点添加到双向链表当中
		doubleLinkedList.add(h1);
		doubleLinkedList.add(h2);
		doubleLinkedList.add(h3);
		doubleLinkedList.add(h4);
		// 显示添加之后的结果
		System.out.println("添加之后的结果----------------------------------");
		doubleLinkedList.list();

		// 修改
		HeroNode2 h5 = new HeroNode2(2, "小卢", "麒麟");
		doubleLinkedList.update(h5);
		// 显示修改之后的结果
		System.out.println("修改之后的结果----------------------------------");
		doubleLinkedList.list();

		// 删除
		doubleLinkedList.del(4);
		// 显示删除之后的结果
		System.out.println("删除之后的结果----------------------------------");
		doubleLinkedList.list();

	}
}

// 创建一个双向链表的类
class DoubleLinkedList {

	// 先初始化一个头节点，头节点不要动，不存放具体的数据
	private HeroNode2 head = new HeroNode2(0, "", "");

	// 返回头节点
	public HeroNode2 getHead() {
		return head;
	}

	// 添加节点的方法
	public void add(HeroNode2 heroNode) {
		// 因为head节点不能动，因此我们需要一个辅助变量temp
		HeroNode2 temp = head;
		// 遍历链表，找到最后
		while (true) {
			// 找到链表的最后
			if (temp.next == null) {
				break;
			}

			// 如果没有找到最后，就将temp后移
			temp = temp.next;
		}
		// 当退出while循环的时候，temp就指向了链表的最后
		// 形成一个双向链表
		temp.next = heroNode;
		heroNode.pre = temp;

	}

	// 修改一个节点的内容
	// 修改节点的信息，根据no编号来修改，即no编号不能改
	// 说明:
	// 1.根据newHeroNode的no来修改
	public void update(HeroNode2 newHeroNode) {
		// 判断是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 找到需要修改的节点，根据no编号
		// 定义一个辅助变量
		HeroNode2 temp = head.next;
		boolean flag = false;// 表示是否找到该节点
		while (true) {
			if (temp == null) {
				break;// 已经遍历完链表了
			}
			if (temp.no == newHeroNode.no) {
				// 找到了
				flag = true;
				break;
			}
			temp = temp.next;

		}
		// 根据flag判断是否找到
		if (flag == true) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else {// 没有找到
			System.out.printf("没有找到编号%d的节点，不能修改\n", newHeroNode.no);

		}
	}

	// 删除节点
	// 思路
	// 1.head不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点
	// 2.说明我们在比较时，是temp.next.no 和 需要删除节点的no比较
	// 对于双向链表，我们可以直接找到要删除的这个节点
	// 找到以后自我删除即可
	public void del(int no) {

		// 判断当前列表是否为空
		if (head.next == null) { // 空链表
			System.out.println("链表为空，无法删除");
			return;
		}

		HeroNode2 temp = head.next; // 辅助变量(指针)
		boolean flag = false;// 标志是否站到待删除节点的前一个节点
		while (true) {
			if (temp == null) {// 已经到链表最后
				break;
			}
			if (temp.no == no) {
				flag = true;
				break;
			}
			temp = temp.next;// temp后移，遍历
		}

		// 判断flag
		if (flag) {// 找到
			// 可以删除
			temp.pre.next = temp.next;

			if (temp.next != null) {
				// 这里我们的代码有问题
				// 如果是最后一个节点，就不需要下面这句话，否则会出现空指针异常
				// 所以我们加上了以上条件，如果后一个元素不为空，在执行下面这句话
				temp.next.pre = temp.pre;
			}

		} else {
			System.out.printf("要删除的%d节点不存在", no);
		}

	}

	// 遍历双向链表的方法
	// 显示链表 通过遍历来完成
	public void list() {
		// 判断链表是否为空
		if (head.next == null) {
			System.out.println("链表为空");
			return;
		}
		// 因为头节点，不能动，因此我们需要一个辅助变量来遍历
		HeroNode2 temp = head.next;
		while (true) {
			// 判断是否为空
			if (temp == null) {
				break;
			}

			// 输出节点的信息
			System.out.println(temp);
			// 将temp后移，一定要小心
			temp = temp.next;
		}
	}

}

// 定义HeroNode2，每一个HeroNode的对象就是一个节点
class HeroNode2 {
	public int no;
	public String name;
	public String nickname;
	public HeroNode2 next;// 指向下一个节点，默认为null
	public HeroNode2 pre;// 指向前一个节点，默认为null

	// 构造器
	public HeroNode2(int no, String name, String nickname) {
		this.no = no;
		this.name = name;
		this.nickname = nickname;
	}

	// 为了显示方法，我们重写toString方法
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + ", nickname="
				+ nickname + "]";
	}

}


```



### 13.约瑟夫问题(环形链表)

```java
/*
	构建一个单向链表的环形链表思路
	1.先创建第一个节点，让first指向该节点，并形成环形
	2.后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表即可
	
	遍历环形链表
	1.先让一个辅助指针(变量)curBoy，指向first节点
	2.然后通过一个while循环遍历该环形链表即可curBoy.next==first结束
*/


/*
	根据用户的输入，生成一个小孩出圈的顺序
	n=5,即有五个人
	k=1,从第一个热开始报数
	m=2，数2下
	
	1.需要创建一个辅助指针(变量)helper,事先应该指向环形链表的最后这个节点
	补充：小孩报数前，显然 first 和 helper 移动 k-1 次
	2.当小孩报数时，让 first 和 helper 指针同时移动 m-1 次
	3.这时就可以将 first 指向的小孩节点出圈 
	first = first.next
	helper.next = first
	出圈顺序 2——>4——>1——>5——>3
*/

public class Joseph {
	public static void main(String[] args) {
		// 测试一把，看看构建环形链表和遍历是否ok
		CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
		circleSingleLinkedList.addBoy(5);
		circleSingleLinkedList.showBoy();

		// 测试一把小孩出圈的顺序是否正确
		circleSingleLinkedList.counBoy(1, 2, 5);

	}
}

// 创建一个环形的单向链表
class CircleSingleLinkedList {
	// 创建一个first节点，当前没有编号
	private Boy first = null;

	// 添加小孩节点，构建一个环形链表
	public void addBoy(int nums) {
		// nums做一个数据校验
		if (nums < 1) {
			System.out.println("nums的值不正确");
			return;
		}

		Boy curBoy = null;
		// 使用for循环来创建环形链表
		for (int i = 1; i <= nums; i++) {
			// 根据编号创建小孩节点
			Boy boy = new Boy(i);
			// 如果是第一个小孩
			if (i == 1) {
				first = boy;
				first.setNext(first);// 构成环形
				curBoy = first;// 让curBoy指向第一个小孩

			} else {
				curBoy.setNext(boy);
				boy.setNext(first);
				curBoy = boy;
			}
		}

	}

	// 遍历当前的环形链表
	public void showBoy() {
		// 判断链表是否为空
		if (first == null) {
			System.out.println("没有任何小孩");
			return;
		}
		// 因为first不能动，所以我们仍然使用一个辅助指针完成遍历
		Boy curBoy = first;
		while (true) {
			System.out.printf("小孩的编号%d \n", curBoy.getNo());
			if (curBoy.getNext() == first) {// 说明已经遍历完毕
				break;
			}
			curBoy = curBoy.getNext();// curBoy后移
		}

	}

	// 根据用户的输入，计算小孩出圈的顺序
	/**
	 * @param startNo
	 *            表示从第几个小孩开始数数
	 * @param countNum
	 *            表示数几下
	 * @param nums
	 *            表示最初有多少个小孩在圈中
	 * 
	 * */
	public void counBoy(int startNo, int countNum, int nums) {
		// 先对数据进行校验
		if (first == null || startNo < 1 || startNo > nums) {
			System.out.println("参数输入有误，请重新输入");
			return;
		}

		// 创建一个指针变量，帮助小孩完成出圈
		Boy helper = first;
		while (true) {
			if (helper.getNext() == first) {// 说明helper指向最后小孩节点
				break;
			}
			helper = helper.getNext();

		}

		// 小孩报数前，先让first和helper移动 startNo-1 次
		for (int j = 0; j < startNo - 1; j++) {
			first = first.getNext();
			helper = helper.getNext();
		}

		// 当小孩报数时，让first和helper指针同时移动 countNum-1 次，然后出圈
		// 这是一个循环的操作，直到圈中只有一个节点
		while (true) {
			if (helper == first) {
				break;
			}
			// 让first和helper指针同时移动 countNum-1 次
			for (int j = 0; j < countNum - 1; j++) {
				first = first.getNext();
				helper = helper.getNext();
			}
			// 这时first指向的节点，就是要出圈的小孩节点
			System.out.printf("小孩%d出圈\n", first.getNo());
			// 这时将first指向的小孩节点出圈
			first = first.getNext();
			helper.setNext(first);
		}
		System.out.printf("最后留在圈中的小孩编号%d\n", first.getNo());

	}

}

// 创建一个Boy类，表示一个点
class Boy {
	private int no;// 编号
	private Boy next;// 指向下一个节点，默认null

	public Boy(int no) {
		this.no = no;
	}

	public int getNo() {
		return no;
	}

	public void setNo(int no) {
		this.no = no;
	}

	public Boy getNext() {
		return next;
	}

	public void setNext(Boy next) {
		this.next = next;
	}

}







```



### 14.数组模拟栈

```java
import java.util.Scanner;

public class ArrayStackDemo {
	public static void main(String[] args) {
		// 测试一下 ArrayStack 是否正确
		// 先创建一个 ArrayStack 对象 ->表示栈
		ArrayStack stack = new ArrayStack(4);
		int key = 0;
		boolean loop = true;
		Scanner scanner = new Scanner(System.in);

		while (loop) {
			System.out.println("1.show:表示显示栈");
			System.out.println("2.exit:退出程序");
			System.out.println("3.push:表示添加数据到栈(入栈)");
			System.out.println("4.pop:表示从栈取出数据(出栈)");
			System.out.println("请输入你的选择");
			key = scanner.nextInt();
			if (key == 1) {
				stack.list();
			} else if (key == 3) {
				System.out.println("请输入一个数字");
				int value = scanner.nextInt();
				stack.push(value);
			} else if (key == 4) {
				try {
					int res = stack.pop();
					System.out.println(res);
				} catch (Exception e) {
					// TODO: handle exception
					System.out.println(e.getMessage());
				}
			} else if (key == 2) {
				scanner.close();
				loop = false;
				break;
			} else {
				System.out.println("输入错误，请重新输入");
			}

		}

		System.out.println("程序退出了");

	}
}

// 定义一个 ArrayStack 表示栈
class ArrayStack {
	private int maxSize;// 栈的大小
	private int[] stack;// 数组，数组模拟栈，数据就该放在数组
	private int top = -1;// top表示栈顶，初始化为-1

	// 构造器
	public ArrayStack(int maxSize) {
		this.maxSize = maxSize;
		stack = new int[this.maxSize];
	}

	// 栈满
	public boolean isFull() {
		return top == maxSize - 1;
	}

	// 栈空
	public boolean isEmpty() {
		return top == -1;
	}

	// 入栈-push
	public void push(int value) {
		// 判断是否栈满
		if (isFull()) {
			System.out.println("栈满");
			return;
		}
		top++;
		stack[top] = value;
	}

	// 出栈-pop，将栈顶的数据返回
	public int pop() {
		// 先判断是否为空
		if (isEmpty()) {
			// 抛出异常
			throw new RuntimeException("栈空,没有数据");
		}
		int value = stack[top];
		top--;
		return value;

	}

	// 显示栈的情况
	public void list() {
		// 先判断是否为空
		if (isEmpty()) {
			System.out.println("栈空，没有数据");
			return;
		}
		// 需要从栈顶显示数据
		for (int i = top; i >= 0; i--) {
			System.out.printf("stack[%d]=%d\n", i, stack[i]);
		}
	}

}

```



### 15.使用栈完成计算表达式的结果

```java
/*
	使用栈完成表达式的计算思路
	1.通过一个index值(索引)，来遍历我们的表达式
	2.如果我们发现是一个数字，就直接入数栈
	3.如果发现扫描到的是一个符号，就分如下情况
		1）如果返现当期那的符号栈为空，就直接入栈
		2）如果符号栈有操作符，就进行比较，如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从			数栈中 pop 出两个数，再从符号栈中 pop 出一个符号，进行运算，将得到结果，入数栈，然后将当前			的操作符入符号栈，如果当前的操作符的优先级大于栈中的操作符，就直接入符号栈。
	4.当表达式扫描完毕，就顺序的从数栈和符号栈中 pop 出相应的数和符号，并运行。
	5.最后在数栈只有一个数字，就是表达式的结果
	
	验证 7*2*2-5+1-5+3-4 = 18
	
*/


public class Calculator {

	public static void main(String[] args) {
		// 根据前面老师思路，完成表达式的运算
		String expression = "7*2*2-5+1-5+3-4"; // 15//如何处理多位数的问题？
		// 创建两个栈，数栈，一个符号栈
		ArrayStack2 numStack = new ArrayStack2(10);
		ArrayStack2 operStack = new ArrayStack2(10);
		// 定义需要的相关变量
		int index = 0;// 用于扫描
		int num1 = 0;
		int num2 = 0;
		int oper = 0;
		int res = 0;
		char ch = ' '; // 将每次扫描得到char保存到ch
		String keepNum = ""; // 用于拼接 多位数
		// 开始while循环的扫描expression
		while (true) {
			// 依次得到expression 的每一个字符
			ch = expression.substring(index, index + 1).charAt(0);
			
			// 判断ch是什么，然后做相应的处理
			if (operStack.isOper(ch)) {// 如果是运算符
				// 判断当前的符号栈是否为空
				if (!operStack.isEmpty()) {
					// 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,
					// 在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈
					if (operStack.priority(ch) <= operStack.priority(operStack.peek())) {
						num1 = numStack.pop();
						num2 = numStack.pop();
						oper = operStack.pop();
						res = numStack.cal(num1, num2, oper);
						// 把运算的结果入数栈
						numStack.push(res);
						// 然后将当前的操作符入符号栈
						operStack.push(ch);
					} else {
						// 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
						operStack.push(ch);
					}
				} else {
					// 如果为空直接入符号栈..
					operStack.push(ch); // 1 + 3
				}
			} else { // 如果是数，则直接入数栈

				// numStack.push(ch - 48); //? "1+3" '1' => 1
				// 分析思路
				// 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数
				// 2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈
				// 3. 因此我们需要定义一个变量 字符串，用于拼接

				// 处理多位数
				keepNum += ch;

				// 如果ch已经是expression的最后一位，就直接入栈
				if (index == expression.length() - 1) {
					numStack.push(Integer.parseInt(keepNum));
				} else {

					// 判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈
					// 注意是看后一位，不是index++
					if (operStack.isOper(expression.substring(index + 1,index + 2).charAt(0))) {
						// 如果后一位是运算符，则入栈 keepNum = "1" 或者 "123"
						numStack.push(Integer.parseInt(keepNum));
						// 重要的!!!!!!, keepNum清空
						keepNum = "";

					}
				}
			}
			// 让index + 1, 并判断是否扫描到expression最后.
			index++;
			if (index >= expression.length()) {
				break;
			}
		}

		// 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.
		while (true) {
			// 如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】
			if (operStack.isEmpty()) {
				break;
			}
			num1 = numStack.pop();
			num2 = numStack.pop();
			oper = operStack.pop();
			res = numStack.cal(num1, num2, oper);
			numStack.push(res);// 入栈
		}
		// 将数栈的最后数，pop出，就是结果
		int res2 = numStack.pop();
		System.out.printf("表达式 %s = %d", expression, res2);
	}

}

// 先创建一个栈,直接使用前面创建好
// 定义一个 ArrayStack2 表示栈, 需要扩展功能
class ArrayStack2 {
	private int maxSize; // 栈的大小
	private int[] stack; // 数组，数组模拟栈，数据就放在该数组
	private int top = -1;// top表示栈顶，初始化为-1

	// 构造器
	public ArrayStack2(int maxSize) {
		this.maxSize = maxSize;
		stack = new int[this.maxSize];
	}

	// 增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop
	public int peek() {
		return stack[top];
	}

	// 栈满
	public boolean isFull() {
		return top == maxSize - 1;
	}

	// 栈空
	public boolean isEmpty() {
		return top == -1;
	}

	// 入栈-push
	public void push(int value) {
		// 先判断栈是否满
		if (isFull()) {
			System.out.println("栈满");
			return;
		}
		top++;
		stack[top] = value;
	}

	// 出栈-pop, 将栈顶的数据返回
	public int pop() {
		// 先判断栈是否空
		if (isEmpty()) {
			// 抛出异常
			throw new RuntimeException("栈空，没有数据~");
		}
		int value = stack[top];
		top--;
		return value;
	}

	// 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据
	public void list() {
		if (isEmpty()) {
			System.out.println("栈空，没有数据~~");
			return;
		}
		// 需要从栈顶开始显示数据
		for (int i = top; i >= 0; i--) {
			System.out.printf("stack[%d]=%d\n", i, stack[i]);
		}
	}

	// 返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示
	// 数字越大，则优先级就越高.
	public int priority(int oper) {
		if (oper == '*' || oper == '/') {
			return 1;
		} else if (oper == '+' || oper == '-') {
			return 0;
		} else {
			return -1; // 假定目前的表达式只有 +, - , * , /
		}
	}

	// 判断是不是一个运算符
	public boolean isOper(char val) {
		return val == '+' || val == '-' || val == '*' || val == '/';
	}

	// 计算方法
	public int cal(int num1, int num2, int oper) {
		int res = 0; // res 用于存放计算的结果
		switch (oper) {
		case '+':
			res = num1 + num2;
			break;
		case '-':
			res = num2 - num1;// 注意顺序
			break;
		case '*':
			res = num1 * num2;
			break;
		case '/':
			res = num2 / num1;
			break;
		default:
			break;
		}
		return res;
	}

}



```



### 16.逆波兰计算器

```java
/*
	前缀、中缀、后缀表达式(逆波兰表达式)
	后缀表达式的计算机求值：
	    从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个		数，用运算符对他们做出相应的计算(次顶元素 和 栈顶元素)，并将结果入栈。重复上述过程	   直到表达式最右端，最后运算得出的值即为表达式的结果
*/


import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
	public static void main(String[] args) {
		// 先定义一个逆波兰表达式
		// (3+4)*5-6 => 3 4 + 5 * 6 -
		// 说明：为了方便，逆波兰表达式的数字和符号使用空格隔开
		String suffixExpression = "3 4 + 5 * 6 -";

		// 思路
		// 1.先将 "3 4 + 5 * 6 -" => 放到ArrayList中
		// 2.将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算

		List<String> rpnList = getListString(suffixExpression);
		System.out.println("rpnList=" + rpnList);

		int res = calculate(rpnList);
		System.out.printf("计算的结果是:%d", res);

	}

	// 将一个逆波兰表达式，依次将数据和运算符放入到 ArrayList中
	public static List<String> getListString(String suffixExpression) {
		// 将 suffixExpression 分割
		String[] split = suffixExpression.split(" ");
		List<String> list = new ArrayList<String>();
		for (String ele : split) {
			list.add(ele);
		}
		return list;
	}

	/*
	 * 完成对逆波兰表达式的运算
	 * 
	 * 1.从左至右扫描，将 3 和 4 压入堆栈 2.遇到 + 运算符，因此弹出 4 和 3 ( 4 为栈顶元素，3 为次栈顶元素)，计算出 3+4
	 * 的值，得 7，再将 7 入栈 3.将 5 入栈 4.接下来是 * 运算符，因此弹出 5 和 7 ，计算出 7*5=35 ， 将 35 入栈 5.将
	 * 6 入栈 6.最后是 - 运算符，计算出 35-6 的值， 即 29 ，由此得出最终结果
	 */

	public static int calculate(List<String> ls) {
		// 创建一个栈
		Stack<String> stack = new Stack<String>();
		// 遍历 ls
		for (String item : ls) {
			// 这里用正则表达式来取出数
			if (item.matches("\\d+")) {// 匹配的是多位数
				// 入栈
				stack.push(item);
			} else {
				// pop出两个数，并运算，在入栈
				int num2 = Integer.parseInt(stack.pop());
				int num1 = Integer.parseInt(stack.pop());
				int res = 0;

				if (item.equals("+")) {
					res = num1 + num2;
				} else if (item.equals("-")) {
					res = num1 - num2;
				} else if (item.equals("*")) {
					res = num1 * num2;
				} else if (item.equals("/")) {
					res = num1 / num2;
				} else {
					throw new RuntimeException("运算符有误");
				}
				// 把 res 入栈 (这里注意要把res转换成字符串，否则无法入栈)
				stack.push(Integer.toString(res));
			}
		}

		// 最后留在stack中的数据是运算结果
		return Integer.parseInt(stack.pop());

	}

}





```

### 17.中缀表达式转后缀表达式

> 1.初始化两个栈：运算符栈s1和储存中间结果的栈s2；
> 2.从左至右扫描中缀表达式；
> 3.遇到操作数时，将其压s2；
> 4.遇到运算符时，比较其与s1栈顶运算符的优先级：
> 	1).如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
> 	2).否则，若优先级比栈顶运算符的高，也将运算符压入s1；
> 	3).否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；
> 5.遇到括号时：
> (1) 如果是左括号“(”，则直接压入s1
> (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢	弃
> 6.重复步骤2至5，直到表达式的最右边
>
> 7.将s1中剩余的运算符依次弹出并压入s2
>8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

**下面表格是中缀表达式转后缀表达式运行步骤**

| 扫描到的元素 | s2(栈底->栈顶)    | s1(栈底->栈顶) | 说明                                     |
| ------------ | ----------------- | :------------- | ---------------------------------------- |
| 1            | 1                 | 空             | 数字，直接入栈                           |
| +            | 1                 | +              | s1为空，运算符直接入栈                   |
| (            | 1                 | + (            | 左括号，直接入栈                         |
| (            | 1                 | + ( (          | 同上                                     |
| 2            | 1 2               | + ( (          | 数字                                     |
| +            | 1 2               | + ( ( +        | s1栈顶为左括号，运算符直接入栈           |
| 3            | 1 2 3             | + ( ( +        | 数字                                     |
| )            | 1 2 3 +           | + (            | 右括号，弹出运算符直至遇到左括号         |
| *            | 1 2 3 +           | + ( *          | s1栈顶为左括号                           |
| 4            | 1 2 3 + 4         | + ( *          | 数字                                     |
| )            | 1 2 3 + 4 *       | +              | 右括号，弹出运算符直至遇到左括号         |
| -            | 1 2 3 + 4 * +     | -              | - 与 + 优先级相同，因此弹出 + ，再压入 - |
| 5            | 1 2 3 + 4 * + 5   | -              | 数字                                     |
| 到达最右端   | 1 2 3 + 4 * + 5 - | 空             | s1中剩余的运算符                         |


```java
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class PolandNotation {
	public static void main(String[] args) {
		// 完成将一个中缀表达式转换成后缀表达式的功能
		/*
		 * 说明 1. 1+((2+3)*4)-5 => 转换成 1 2 3 + 4 * + 5 - 2. 因为直接对 str
		 * 进行操作，不方便，因此先将 "1+((2+3)*4)-5" => 转换成中缀表达式的list形式 即"1+((2+3)*4)-5" =>
		 * ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] 3.将得到的中缀表达式对应的List =>
		 * 后缀表达式对应的List 即ArrayList[1,+,(,(,2,+,3,),*,4,),-,5] =>
		 * ArrayList[1,2,3,+,4,*,+,5,-]
		 */

		// 表达式
		String expression = "1+((2+3)*4)-5";
		// 字符串表达式转换成中缀表达式
		List<String> infixExpressionList = toInfixExpressionList(expression);
		System.out.println("中缀表达式对应List=" + infixExpressionList);// ArrayList[1,+,(,(,2,+,3,),*,4,),-,5]
		// 中缀表达式转化成后缀表达式
		List<String> parseSuffixExpression = parseSuffixExpression(infixExpressionList);
		System.out.println("后缀表达式对应的List" + parseSuffixExpression);
		// 调用计算方法 计算出来结果输出
		int res = calculate(parseSuffixExpression);
		System.out.printf("计算的结果是:%d", res);

	}

	// 方法：将得到的中缀表达式对应的 List => 后缀表达式对应的 List
	public static List<String> parseSuffixExpression(List<String> ls) {
		// 定义两个栈
		Stack<String> s1 = new Stack<String>();
		// 说明：因为s2这个栈，在整个转换的过程当中，没有pop操作，而且后面我们还要逆序输出，
		// 因此比较麻烦，这里我们就不用Stack<Strig>直接使用ArrayList<String> s2
		List<String> s2 = new ArrayList<String>();// 存储中间结果 List s2

		// 遍历 s2
		for (String item : ls) {
			// 如果是一个数，加入s2
			if (item.matches("\\d+")) {
				s2.add(item);
			} else if (item.equals("(")) {
				s1.push(item);
			} else if (item.equals(")")) {
				// 如果是右括号 ，则依次弹出s1栈顶的运算符，并压入s2，知道遇到左括号为止，此时将这一对括号丢弃
				while (!s1.peek().equals("(")) {// peek查看栈顶的内容，但是不弹出
					s2.add(s1.pop());
				}
				s1.pop();// 将左括号弹出 s1 栈，消除小括号
			} else {
				// 当item的优先级小于s1栈顶运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到 4.1步骤 与s1的栈顶运算符做比较
				while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)) {
					s2.add(s1.pop());
				}
				s1.push(item);
			}
		}

		// 将s1中剩余的运算符依次弹出，并加入到s2
		while (s1.size() != 0) {
			s2.add(s1.pop());
		}

		return s2;// 注意，因为是存放到List，因此按顺序输出就是对应的后缀表达式对应的List

	}

	// 方法：将中缀表达式转换成相应的List
	public static List<String> toInfixExpressionList(String s) {
		// 定义一个List，存放中缀表达式对应的内容
		List<String> ls = new ArrayList<String>();
		int i = 0;// 这是一个指针，用来遍历中缀表达式字符串
		String str;// 对多位数的拼接
		char c;// 每遍历到一个字符，就放入c

		do {
			// 如果c是一个非数字，我需要加入到ls
			if ((c = s.charAt(i)) < 48 || (c = s.charAt(i)) > 57) {
				ls.add("" + c);
				i++;// i需要后移

			} else {
				str = "";
				while (i < s.length() && (c = s.charAt(i)) >= 48
						&& (c = s.charAt(i)) <= 57) {
					str += c;// 拼接
					i++;
				}
				ls.add(str);
			}

		} while (i < s.length());

		return ls;

	}

	// 将一个逆波兰表达式，依次将数据和运算符放入到 ArrayList中
	public static List<String> getListString(String suffixExpression) {
		// 将 suffixExpression 分割
		String[] split = suffixExpression.split(" ");
		List<String> list = new ArrayList<String>();
		for (String ele : split) {
			list.add(ele);
		}
		return list;
	}

	/*
	 * 完成对逆波兰表达式的运算
	 * 
	 * 1.从左至右扫描，将 3 和 4 压入堆栈 2.遇到 + 运算符，因此弹出 4 和 3 ( 4 为栈顶元素，3 为次栈顶元素)，计算出 3+4
	 * 的值，得 7，再将 7 入栈 3.将 5 入栈 4.接下来是 * 运算符，因此弹出 5 和 7 ，计算出 7*5=35 ， 将 35 入栈 5.将
	 * 6 入栈 6.最后是 - 运算符，计算出 35-6 的值， 即 29 ，由此得出最终结果
	 */

	public static int calculate(List<String> ls) {
		// 创建一个栈
		Stack<String> stack = new Stack<String>();
		// 遍历 ls
		for (String item : ls) {
			// 这里用正则表达式来取出数
			if (item.matches("\\d+")) {// 匹配的是多位数
				// 入栈
				stack.push(item);
			} else {
				// pop出两个数，并运算，在入栈
				int num2 = Integer.parseInt(stack.pop());
				int num1 = Integer.parseInt(stack.pop());
				int res = 0;

				if (item.equals("+")) {
					res = num1 + num2;
				} else if (item.equals("-")) {
					res = num1 - num2;
				} else if (item.equals("*")) {
					res = num1 * num2;
				} else if (item.equals("/")) {
					res = num1 / num2;
				} else {
					throw new RuntimeException("运算符有误");
				}
				// 把 res 入栈 (这里注意要把res转换成字符串，否则无法入栈)
				stack.push(Integer.toString(res));
			}
		}

		// 最后留在stack中的数据是运算结果
		return Integer.parseInt(stack.pop());

	}

}

// 编写一个类Operation 可以返回一个运算符对应的优先级
class Operation {
	private static int ADD = 1;
	private static int SUB = 1;
	private static int MUL = 2;
	private static int DIV = 2;

	// 写一个方法，返回对应的优先级数字
	public static int getValue(String operation) {
		int result = 0;
		switch (operation.charAt(0)) {
		case '+':
			result = ADD;
			break;
		case '-':
			result = SUB;
			break;
		case '*':
			result = MUL;
			break;
		case '/':
			result = DIV;
			break;
		default:
			System.out.println("不存在该运算符");
			break;
		}

		return result;
	}

}

```



### 18.递归的调用机制(打印&阶乘)



![image-20200130142737621]( \img\image-20200130142737621.png)

```java
/*
  
  递归需要遵守的重要规则
  	1.执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
  	2.方法的局部变量是独立的，不会互相影响，比如n变量
  	3.如果方法中使用的是引用类型变量(比如数组),就会共享引用类型数据
  	4.递归必须向退出递归的条件逼近，否则即使无限递归了，出现StackOverflowError
  	5.当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用就将结果返回给谁，
  	同时当方法执行完毕或者返回时，该方法也就执行完毕
  	
 */


public class RecursionTest {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		test(4);
		System.out.println(factorial(3));
	}

	// 打印问题
	public static void test(int n) {
		if (n > 2) {
			test(n - 1);
		} else {
			System.out.println("n=" + n);
		}
	}

	// 阶乘问题
	public static int factorial(int n) {
		if (n == 1) {
			return 1;
		} else {
			return factorial(n - 1) * n;
		}
	}

}


```



### 19.递归-迷宫问题

```java
/*
 * 使用递归回溯来给小球找路
 * 说明
 * 1.map表示地图
 * 2.i j 表示从地图的哪个位置开始出发(1,1)
 * 3.如果小球能到map[6][5]位置，则说明通路找到
 * 4.约定：当map[i][j]为0表示该点没有走过 当为1表示墙；2表示通路可以走；3表示该点已经走过，但是走不通
 * 5.在走迷宫时，需要确定一下策略(方法) 下 -> 右 -> 上 -> 左
 * 
 * 
 * 
 * */
public class MiGong {
	public static void main(String[] args) {
		// 先创建一个二维数组，模拟迷宫
		// 地图
		int[][] map = new int[8][7];
		// 使用 1 来表示墙
		// 上下全部置 1
		for (int i = 0; i < 7; i++) {
			map[0][i] = 1;
			map[7][i] = 1;
		}

		for (int i = 0; i < 8; i++) {
			map[i][0] = 1;
			map[i][6] = 1;
		}
		// 设置路障
		for (int i = 0; i < 3; i++) {
			map[3][i] = 1;
		}

		// 开始走迷宫,并输入是否走到了终点
		System.out.println("是否走到了终点:" + setWay(map, 1, 1));

		// 小球走过，并标识过的地图
		for (int i = 0; i < 8; i++) {
			for (int j = 0; j < 7; j++) {
				System.out.printf("%d ", map[i][j]);
			}
			System.out.println();
		}

	}

	/**
	 * 
	 * @param map 	表示地图
	 * @param i 	从哪个位置开始走
	 * @param j
	 * @return 		如果找到通路就返回true ，否则返回false
	 * 
	 * */

	public static boolean setWay(int[][] map, int i, int j) {
		if (map[6][5] == 2) {
			return true;
		} else {
			if (map[i][j] == 0) {// 如果当前这个点还没有走过
				// 按照策略走： 下 -> 右 -> 上 -> 左
				map[i][j] = 2;// 假定该点是可以走通的
				if (setWay(map, i + 1, j)) {// 向下走
					return true;
				} else if (setWay(map, i, j + 1)) {// 向右走
					return true;
				} else if (setWay(map, i - 1, j)) {// 向上走
					return true;
				} else if (setWay(map, i, j - 1)) {// 向左走
					return true;
				} else {
					// 说明该点是走不通的，是死路
					map[i][j] = 3;
					return false;
				}

			} else {// 如果map[i][j]!=0 则可能是 1 2 3
				return false;
			}
		}

	}

}

```



### 20.八皇后问题

```java
/*
	1.第一个皇后先放第一行第一列
	2.第二个皇后放在第二行第一列，然后判断是否ok，如果不ok，继续放在第二列、第三列、以此把所有列都放		完，找到一个合适的
	3.继续第三个皇后，还是第一列、第二列.....直到第八个皇后也能放在一个不冲突的位置，算是找到了一个正	确解
	4.当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解
	全部得到
	5.然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤
	
	说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题. 	arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} //对应arr 下标 表示第几行，即第几个皇后，
	arr[i] = val 	, val 表示第i+1个皇后，放在第i+1行的第val+1列
	
*/

public class Queen8 {

	// 定义一个max表示有多少个皇后
	int max = 8;
	// 定义数组array，保存皇后放置位置的结果，比如arr={0,4,7,5,2,6,,1,3}
	int[] array = new int[max];
	static int count = 0;
	static int judgeCount=0;

	public static void main(String[] args) {
		// 测试一把是否正确
		Queen8 queen8 = new Queen8();
		queen8.check(0);
		System.out.printf("一共有%d种解法", count);
		System.out.printf("一共判断冲突的次数为%d次", judgeCount);
	}

	// 编写一个方法，放置第n个皇后
	// 特别注意：check是每一次递归时进入到check中都有一套for循环，因此会有回溯
	private void check(int n) {
		if (n == max) {
			print();
			return;
		}

		// 依次放入皇后，并判断是否冲突
		for (int i = 0; i < max; i++) {
			// 先把当前这个皇后n，放到该行的第1列
			array[n] = i;
			// 判断放置第n个皇后到i列时，是否冲突
			if (judge(n)) {// 不冲突
				// 接着放n+1个皇后，即开始递归
				check(n + 1);

			}
			// 如果冲突，就继续执行array[n]=1; 即将第n个皇后，放置在本行的后移一列的位置
		}
	}

	// 查看我们放置的第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突
	/**
	 * @param n表示第n个皇后
	 * @return
	 * 
	 * 
	 * */
	private boolean judge(int n) {
		judgeCount++;
		for (int i = 0; i < n; i++) {
			/*
			 * 1. array[i] == array[n] 表示判断第n个皇后是否和前面的n-1个皇后在同一列 
			 * 2. Math.abs(n -i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 
			 * n = 1 放置第2列 1 n=1 array[1]=1 Math.abs(1-0) == 1
			 * Math.abs(array[n]-array[i])=Math.abs(1-0)=1
			 * 3.判断是否在同一行，没有必要，n每次都在递增
			 */
			if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
				return false;
			}
		}
		return true;

	}

	// 写一个方法,可以将皇后摆放的位置输出
	private void print() {
		count++;
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}
		System.out.println();
	}

}

```



### 21.冒泡排序

**1.图示过程**

![img]( \img\webp1233)

**2.动画展示**

![img]( \img\webp222)

```java
/*

冒泡排序解析：
	1.原理：比较两个相邻的元素，将值大的元素交换到右边

	2.思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。

　　　　(1)第一次比较：首先比较第一和第二个数，将小数放在前面，将大数放在后面。

　　　　(2)比较第2和第3个数，将小数 放在前面，大数放在后面。

　　　　......

　　　　(3)如此继续，知道比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成

　　　　(4)在上面一趟比较完成后，最后一个数一定是数组中最大的一个数，所以在比较第二趟的时候，最后一个		数是不参加比较的。

　　　　(5)在第二趟比较完成后，倒数第二个数也一定是数组中倒数第二大数，所以在第三趟的比较中，最后两个		数是不参与比较的。

　　　　(6)依次类推，每一趟比较次数减少依次
*/


import java.text.SimpleDateFormat;
import java.util.Date;

public class BubbleSort {
	public static void main(String[] args) {
		// 冒泡排序，时间复杂度O(n^2)

		/*
		 * 测试一下冒泡排序的速度，给8w个数据，测试 创建要给8w个随机数的数组
		 */
		int[] arr = new int[8000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 8000);
		}

		Date date1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateStr1 = simpleDateFormat.format(date1);
		System.out.println("排序前的时间是:" + dateStr1);

		bubbleSort(arr);

		Date date2 = new Date();
		String dateStr2 = simpleDateFormat.format(date2);
		System.out.println("排序后的时间是:" + dateStr2);

		// // 输出排序过后的数组
		// for (int i = 0; i < arr.length; i++) {
		// System.out.printf("%d ", arr[i]);
		// }

	}

	// 将冒泡排序封装成一个方法来测试
	public static void bubbleSort(int[] arr) {
		int temp = 0;// 临时变量
		boolean flag = false;// 标识变量，表示是否进行过交换
		for (int i = 0; i < arr.length - 1; i++) {

			for (int j = 0; j < arr.length - 1 - i; j++) {
				// 如果前面的数比后面的数大，则交换
				if (arr[j] > arr[j + 1]) {
					flag = true;
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}

			// System.out.printf("完成了第%d趟排序\n", i + 1);

			if (flag == false) {// 在本趟排序中，一次交换都没有发生过(说明排序已经完成)
				break;
			} else {
				flag = false;// 重置flag，进行下一次判断
			}

		}

	}
}  



```

### 22.选择排序

**1.图示过程**

![img]( \img\webp123)

**2.动画展示**

![img]( \img\webp23)

```java
/*
	选择排序是选择一个位置进行排序，将有序元素排放在数组最左边。

	第一轮排序

	选择数组的第一个位置上的元素开始与其他元素进行逐个比较，即index[0]与index[1]、index[2]、		index[3]、index[4]、index[5]、index[6]、index[7]、index[8]、index[9]比较，

	将最小的元素放在index[0]所在的位置上。（期间进项相互比较和复制）。

	第二轮排序

	选择数组的第二个位置上的元素开始与其他元素进行逐个比较，即index[1]与index[2]、index[3]、		index[4]、index[5]、index[6]、index[7]、index[8]、index[9]比较,

	将最小的一个元素放在index[1]所在的位置上。

	第三轮排序

	。。。。

	直到整个数组有序。
	
	选择排序要比冒泡排序所用的时间要短  
*/


import java.text.SimpleDateFormat;
import java.util.Date;

public class SelectSort {
	public static void main(String[] args) {
		int[] arr = new int[80000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 80000);
		}

		Date date1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateStr1 = simpleDateFormat.format(date1);
		System.out.println("排序前的时间是:" + dateStr1);

		selectSort(arr);

		Date date2 = new Date();
		String dateStr2 = simpleDateFormat.format(date2);
		System.out.println("排序后的时间是:" + dateStr2);

		// // 输出排序过后的数组
		// for (int i = 0; i < arr.length; i++) {
		// System.out.printf("%d ", arr[i]);
		// }
	}

	// 选择排序
	// 时间复杂度：O(n^2)
	public static void selectSort(int[] arr) {
		/*
		 * 使用逐步推导的方式来，讲解选择排序 第一轮 原始数组： 101，34，119，1 第一轮排序：1,34，119,101
		 * 算法：先简单->后复杂，就是可以把一个简单的算法，拆分成简单的问题->逐步解决
		 */

		for (int i = 0; i < arr.length; i++) {
			int minIndex = i;
			int min = arr[i];
			for (int j = i + 1; j < arr.length; j++) {
				if (min > arr[j]) {// 说明假定的最小值，并不是最小
					min = arr[j];// 重置min
					minIndex = j;// 重置minIndex
				}
			}

			// 将最小值，放在arr[0]，即交换
			if (minIndex != i) {
				arr[minIndex] = arr[i];
				arr[i] = min;
			}
		}
	}
}

```



### 23.插入排序

**1.图示过程**

![img]( \img\webp4)

**2.动画展示**

![7789414-d3e7769cd797534d]( \img\7789414-d3e7769cd797534d.gif)



```java
/*
		首先来解释一下插入排序法的原理，它的原理是每插入一个数都要将它和之前的已经完成排序的序列进行		重新排序，也就是要找到新插入的数对应原序列中的位置。那么也就是说，每次插入一个数都要对原来排序好	  的那部分序列进行重新的排序，时间复杂度同样为O（n²）。 这种算法是稳定的排序方法。
	
	
	我们要做的从a[1]开始，至于为什么不是a[0]。a[0]之前没有与a[0]进行比较的元素。我们插入a[1]，这个	时候我们需要遍历a[1]和a[1]之前的所有元素进行比较。这个时候我们需要设置一个变量j，用来记录第一个 	比 a[1]元素小的那个元素的下标，也就是a[1]要插入的位置，这个时候跳出循环，并且每发现一个比a[1]大的		元素，就要令这个元素后移一位。依次类推的算法直到整个数组的最后一个。

	以a[4]为例，假设a[3](注意，这个地方，从a[0]到a[3]已经完成了排序)小于 a[4]，那么就j的值是 3那		么这个时候 a[4] 就应该放在 下标是3+1 = 4的位置处

	
*/




import java.text.SimpleDateFormat;
import java.util.Date;

public class InsertSort {
	public static void main(String[] args) {
		int[] arr = new int[80000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 80000);
		}

		Date date1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateStr1 = simpleDateFormat.format(date1);
		System.out.println("排序前的时间是:" + dateStr1);

		insertSort(arr);

		Date date2 = new Date();
		String dateStr2 = simpleDateFormat.format(date2);
		System.out.println("排序后的时间是:" + dateStr2);
	}

	// 插入排序
	public static void insertSort(int[] arr) {
		// 使用逐步推导的方式来讲解，便于理解
		// 使用for循环来让代码简化
		for (int i = 1; i < arr.length; i++) {
			int insertVal = arr[i];// 定义待插入的数
			int insertIndex = i - 1;// 即arr[i]的前面这个数的下标
			/*
			 * 给insertVal 找到插入的位置 说明 1.insertVal >=0保证在给insertVal找插入位置不越界
			 * 2.insertVal < arr[insertIndex] 待插入的数还没有找到插入位置
			 * 3.就需要将arr[insertIndex]后移
			 */
			while (insertIndex >= 0 && insertVal < arr[insertIndex]) {
				arr[insertIndex + 1] = arr[insertIndex];
				insertIndex--;
			}
			// 当退出while循环时，说明插入的位置找到，insertIndex+1
			// 这里判断我们是否需要赋值
			if ((insertIndex + 1) != i) {
				arr[insertIndex + 1] = insertVal;
			}

		}
	}
}

```



### 24.希尔排序(交换法)

>**希尔**排序法介绍
>
>
>
>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种**插入排序**，它是简单插入排序经过改进之后的一个**更高效的版本**，也称为缩小增量排序。
>
>
>
>**希尔排序法基本思想**
>
>
>
>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止
>
>1)希尔排序时， 对有序序列在插入时采用**交换**法, 并测试排序速度.
>
>2)希尔排序时， 对有序序列在插入时**采用移动**法, 并测试排序速度
>
>



![image-20200201135732431]( \img\image-20200201135732431.png)

```java
import java.text.SimpleDateFormat;
import java.util.Date;

public class ShellSort {
	public static void main(String[] args) {
		int[] arr = new int[80000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 80000);
		}
		Date date1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateStr1 = simpleDateFormat.format(date1);
		System.out.println("排序前的时间是:" + dateStr1);

		shellSort(arr);

		Date date2 = new Date();
		String dateStr2 = simpleDateFormat.format(date2);
		System.out.println("排序后的时间是:" + dateStr2);
	}

	// 希尔排序时，对有序序列在插入时采用交换法
	public static void shellSort(int[] arr) {

		int temp = 0;
		// 根据前面的逐步分析，使用循环处理

		for (int gap = arr.length / 2; gap > 0; gap /= 2) {
			// 遍历各组中所有的元素(共gap组，每组有2个元素)，步长gap
			for (int i = gap; i < arr.length; i++) {
				for (int j = i - gap; j >= 0; j -= gap) {
					// 如果当前元素大于加上步长后的那个元素，说明交换
					if (arr[j] > arr[j + gap]) {
						temp = arr[j];
						arr[j] = arr[j + gap];
						arr[j + gap] = temp;
					}
				}
			}
		}

	}
}

```



### 25.希尔排序(移位法)

```java
import java.text.SimpleDateFormat;
import java.util.Date;

public class ShellSort {
	public static void main(String[] args) {
		int[] arr = new int[80000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 80000);
		}
		Date date1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateStr1 = simpleDateFormat.format(date1);
		System.out.println("排序前的时间是:" + dateStr1);

		shellSort(arr);

		Date date2 = new Date();
		String dateStr2 = simpleDateFormat.format(date2);
		System.out.println("排序后的时间是:" + dateStr2);
	}

	// 对交换式的希尔排序进行优化 -> 移位法
	public static void shellSort(int[] arr) {
		// 增量gap，并逐步的缩小增量
		for (int gap = arr.length / 2; gap > 0; gap /= 2) {
			// 从第gap个元素，逐个对其所在的组进行插入排序
			for (int i = gap; i < arr.length; i++) {
				int j = i;
				int temp = arr[j];
				if (arr[i] < arr[j - gap]) {
					while (j - gap >= 0 && temp < arr[j - gap]) {
						// 移动
						arr[j] = arr[j - gap];
						j -= gap;
					}
					// 当退出while后，就给temp找到插入位置
					arr[j] = temp;
				}
			}
		}

	}

}

```



### 26.快速排序

**1.总体流程**

![img]( \img\webp11)

**2.动画展示**

![img]( \img\webp111)

```java
/*
	快速排序(QuickSort)是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序郭晨可以递归进行，以此达到整个数据变成有序序列。
	
	1.从数列中挑出一个元素，称为 “基准”（pivot）;

2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；
	
	
*/


import java.text.SimpleDateFormat;
import java.util.Date;

public class QuickSort {

	public static void main(String[] args) {
		int[] arr = new int[80000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 80000);
		}
		Date date1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String dateStr1 = simpleDateFormat.format(date1);
		System.out.println("排序前的时间是:" + dateStr1);

		quickSort(arr,0,arr.length-1);

		Date date2 = new Date();
		String dateStr2 = simpleDateFormat.format(date2);
		System.out.println("排序后的时间是:" + dateStr2);
		
	}

	public static void quickSort(int[] arr,int left, int right) {
		int l = left; //左下标
		int r = right; //右下标
		//pivot 中轴值
		int pivot = arr[(left + right) / 2];
		int temp = 0; //临时变量，作为交换时使用
		//while循环的目的是让比pivot 值小放到左边
		//比pivot 值大放到右边
		while( l < r) { 
			//在pivot的左边一直找,找到大于等于pivot值,才退出
			while( arr[l] < pivot) {
				l += 1;
			}
			//在pivot的右边一直找,找到小于等于pivot值,才退出
			while(arr[r] > pivot) {
				r -= 1;
			}
			//如果l >= r说明pivot 的左右两的值，已经按照左边全部是
			//小于等于pivot值，右边全部是大于等于pivot值
			if( l >= r) {
				break;
			}
			
			//交换
			temp = arr[l];
			arr[l] = arr[r];
			arr[r] = temp;
			
			//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移
			if(arr[l] == pivot) {
				r -= 1;
			}
			//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移
			if(arr[r] == pivot) {
				l += 1;
			}
		}
		
		// 如果 l == r, 必须l++, r--, 否则为出现栈溢出
		if (l == r) {
			l += 1;
			r -= 1;
		}
		//向左递归
		if(left < r) {
			quickSort(arr, left, r);
		}
		//向右递归
		if(right > l) {
			quickSort(arr, l, right);
		}
		
		
	}
}



```



### 27.归并排序

**1.归并排序流程**

![img](\img\webp)

**2.合并两个有序数组的流程**

![img](\img\webp2)

**3.动画展示**

![img](\img\webp3)



```java
import java.text.SimpleDateFormat;
import java.util.Date;

public class MergetSort {

	public static void main(String[] args) {

		int[] arr = new int[8000000];
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 8000000);
		}
		System.out.println("排序前");
		Date data1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String date1Str = simpleDateFormat.format(data1);
		System.out.println("排序前的时间是=" + date1Str);

		int temp[] = new int[arr.length]; // 归并排序需要一个额外空间
		mergeSort(arr, 0, arr.length - 1, temp);

		Date data2 = new Date();
		String date2Str = simpleDateFormat.format(data2);
		System.out.println("排序前的时间是=" + date2Str);

	}

	// 分+合方法
	public static void mergeSort(int[] arr, int left, int right, int[] temp) {
		if (left < right) {
			int mid = (left + right) / 2; // 中间索引
			// 向左递归进行分解
			mergeSort(arr, left, mid, temp);
			// 向右递归进行分解
			mergeSort(arr, mid + 1, right, temp);
			// 合并
			merge(arr, left, mid, right, temp);

		}
	}

	// 合并的方法
	/**
	 * 
	 * @param arr
	 *            排序的原始数组
	 * @param left
	 *            左边有序序列的初始索引
	 * @param mid
	 *            中间索引
	 * @param right
	 *            右边索引
	 * @param temp
	 *            做中转的数组
	 */
	public static void merge(int[] arr, int left, int mid, int right, int[] temp) {

		int i = left; // 初始化i, 左边有序序列的初始索引
		int j = mid + 1; // 初始化j, 右边有序序列的初始索引
		int t = 0; // 指向temp数组的当前索引

		// (一)
		// 先把左右两边(有序)的数据按照规则填充到temp数组
		// 直到左右两边的有序序列，有一边处理完毕为止
		while (i <= mid && j <= right) {// 继续
			// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素
			// 即将左边的当前元素，填充到 temp数组
			// 然后 t++, i++
			if (arr[i] <= arr[j]) {
				temp[t] = arr[i];
				t += 1;
				i += 1;
			} else { // 反之,将右边有序序列的当前元素，填充到temp数组
				temp[t] = arr[j];
				t += 1;
				j += 1;
			}
		}

		// (二)
		// 把有剩余数据的一边的数据依次全部填充到temp
		while (i <= mid) { // 左边的有序序列还有剩余的元素，就全部填充到temp
			temp[t] = arr[i];
			t += 1;
			i += 1;
		}

		while (j <= right) { // 右边的有序序列还有剩余的元素，就全部填充到temp
			temp[t] = arr[j];
			t += 1;
			j += 1;
		}

		// (三)
		// 将temp数组的元素拷贝到arr
		// 注意，并不是每次都拷贝所有
		t = 0;
		int tempLeft = left; //
		// 第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tL=0 ri=3
		// 最后一次 tempLeft = 0 right = 7
		while (tempLeft <= right) {
			arr[tempLeft] = temp[t];
			t += 1;
			tempLeft += 1;
		}

	}

}

```

### 28.基数排序

>
>
>相比其它排序，主要是利用比较和交换，而基数排序则是利用分配和收集两种基本操作。基数 排序是一种按记录关键字的各位值逐步进行排序的方法。此种排序一般适用于记录的关键字为整数类型的情况。所有对于字符串和文字排序不适合。
>
>   实现：将所有待比较数值（自然数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。
>
>   基数排序的两种方式：
>
>1. 高位优先，又称为最有效键(MSD),它的比较方向是由右至左；
>
>2. 低位优先，又称为最无效键(LSD),它的比较方向是由左至右；
>
>   

**1.图解**

![基数排序实例1]( \img\1469176-20190401231001151-1822924042.png)

**2.动画展示**

![堆排序动画演示]( \img\1469176-20190401231003889-1072941310.gif)

```java
public class RadixSort {
	public static void main(String[] args) {
		int[] arr = { 63, 157, 189, 51, 101, 47, 141, 121, 157, 156, 194, 117,98, 139, 67, 133, 181, 12, 28, 0, 109 };

		radixSort(arr);

		for(int i = 0;i<arr.length;i++){
			System.out.printf("%d ", arr[i]);
		}
	}

	/**
	 * 高位优先法
	 * 
	 * @param arr
	 *            待排序列，必须为自然数
	 */
	private static void radixSort(int[] arr) {
		// 待排序列最大值
		int max = arr[0];
		int exp;// 指数

		// 计算最大值
		for (int anArr : arr) {
			if (anArr > max) {
				max = anArr;
			}
		}

		// 从个位开始，对数组进行排序
		for (exp = 1; max / exp > 0; exp *= 10) {
			// 存储待排元素的临时数组
			int[] temp = new int[arr.length];
			// 分桶个数
			int[] buckets = new int[10];

			// 将数据出现的次数存储在buckets中
			for (int value : arr) {
				// (value / exp) % 10 :value的最底位(个位)
				buckets[(value / exp) % 10]++;
			}

			// 更改buckets[i]，
			for (int i = 1; i < 10; i++) {
				buckets[i] += buckets[i - 1];
			}

			// 将数据存储到临时数组temp中
			for (int i = arr.length - 1; i >= 0; i--) {
				temp[buckets[(arr[i] / exp) % 10] - 1] = arr[i];
				buckets[(arr[i] / exp) % 10]--;
			}

			// 将有序元素temp赋给arr
			System.arraycopy(temp, 0, arr, 0, arr.length);
		}

	}
}
```



### 29.线性查找

```java

public class SeqSearch {
	public static void main(String[] args){
		int arr[] = {1,9,11,-1,34,89};
		int index = seqSearch(arr,1);
		if(index == -1){
			System.out.println("没找到");
		}else{
			System.out.println("找到了，下标为:"+index);
		}
	}
	
	public static 	int seqSearch(int [] arr,int value){
		//线性查找是逐一比对，发现有相同的值，就返回下标
		for(int i = 0;i<arr.length;i++){
			if(arr[i]==value){
				return i;
			}
		}
		
		return -1;
	}
}

```



### 30.二分查找

```java
/*
 二分查找的思路分析
1. 首先确定该数组的中间的下标
mid = (left + right) / 2
2. 然后让需要查找的数 findVal 和 arr[mid] 比较
2. 1 findVal > arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找
2.2 findVal < arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找
2.3  findVal == arr[mid] 说明找到，就返回

//什么时候我们需要结束递归.
1) 找到就结束递归 
2) 递归完整个数组，仍然没有找到findVal ，也需要结束递归  当 left > right 就需要退出

 
 */


import java.util.ArrayList;
import java.util.List;

//注意：使用二分查找的前提是 该数组是有序的.
public class BinarySearch {

	public static void main(String[] args) {
		//int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };
		int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 };
		

		//
//		int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);
//		System.out.println("resIndex=" + resIndex);
		
		List<Integer> resIndexList = binarySearch2(arr, 0, arr.length - 1, 1);
		System.out.println("resIndexList=" + resIndexList);
	}

	// 二分查找算法
	/**
	 * 
	 * @param arr
	 *            数组
	 * @param left
	 *            左边的索引
	 * @param right
	 *            右边的索引
	 * @param findVal
	 *            要查找的值
	 * @return 如果找到就返回下标，如果没有找到，就返回 -1
	 */
	public static int binarySearch(int[] arr, int left, int right, int findVal) {
		

		// 当 left > right 时，说明递归整个数组，但是没有找到
		if (left > right) {
			return -1;
		}
		int mid = (left + right) / 2;
		int midVal = arr[mid];

		if (findVal > midVal) { // 向 右递归
			return binarySearch(arr, mid + 1, right, findVal);
		} else if (findVal < midVal) { // 向左递归
			return binarySearch(arr, left, mid - 1, findVal);
		} else {
			
			return mid;
		}

	}
	
	//完成一个课后思考题:
	/*
	 * 课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，
	 * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000
	 * 
	 * 思路分析
	 * 1. 在找到mid 索引值，不要马上返回
	 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
	 * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
	 * 4. 将Arraylist返回
	 */

	public static List<Integer> binarySearch2(int[] arr, int left, int right, int findVal) {

		System.out.println("hello~");
		// 当 left > right 时，说明递归整个数组，但是没有找到
		if (left > right) {
			return new ArrayList<Integer>();
		}
		int mid = (left + right) / 2;
		int midVal = arr[mid];

		if (findVal > midVal) { // 向 右递归
			return binarySearch2(arr, mid + 1, right, findVal);
		} else if (findVal < midVal) { // 向左递归
			return binarySearch2(arr, left, mid - 1, findVal);
		} else {
//			 * 思路分析
//			 * 1. 在找到mid 索引值，不要马上返回
//			 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
//			 * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
//			 * 4. 将Arraylist返回
			
			List<Integer> resIndexlist = new ArrayList<Integer>();
			//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
			int temp = mid - 1;
			while(true) {
				if (temp < 0 || arr[temp] != findVal) {//退出
					break;
				}
				//否则，就temp 放入到 resIndexlist
				resIndexlist.add(temp);
				temp -= 1; //temp左移
			}
			resIndexlist.add(mid);  //
			
			//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList
			temp = mid + 1;
			while(true) {
				if (temp > arr.length - 1 || arr[temp] != findVal) {//退出
					break;
				}
				//否则，就temp 放入到 resIndexlist
				resIndexlist.add(temp);
				temp += 1; //temp右移
			}
			
			return resIndexlist;
		}

	}
}

```



### 31.差值查找

>**插值查找原理介绍****:**
>
> 
>
>1)插值查找算法类似于二分查找，不同的是插值查找每次从**自适应****mid**处开始查找。
>
>2)将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.
> key 就是前面我们讲的 findVal
>
>![image-20200203144620746](\img\1.png)
>
>
>
>3)int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;/*插值索引*/
> 对应前面的代码公式：
> int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
>
>4)举例说明插值查找算法 1-100 的数组
>
>
>
>差值查找注意事项：
>
>1.对于数量较大，关键字分布比较均匀的查找表来说，采用插值查找速度较快
>
>2.关键字分布不均匀的情况下，该方法不一定比折半查找要好
>
>

```java

import java.util.Arrays;

public class InsertValueSearch {

	public static void main(String[] args) {
		
//		int [] arr = new int[100];
//		for(int i = 0; i < 100; i++) {
//			arr[i] = i + 1;
//		}
		
		int arr[] = { 1, 8, 10, 89,1000,1000, 1234 };
		
		int index = insertValueSearch(arr, 0, arr.length - 1, 1234);
		//int index = binarySearch(arr, 0, arr.length, 1);
		System.out.println("index = " + index);
		
		//System.out.println(Arrays.toString(arr));
	}
	
	public static int binarySearch(int[] arr, int left, int right, int findVal) {
		System.out.println("二分查找被调用~");
		// 当 left > right 时，说明递归整个数组，但是没有找到
		if (left > right) {
			return -1;
		}
		int mid = (left + right) / 2;
		int midVal = arr[mid];

		if (findVal > midVal) { // 向 右递归
			return binarySearch(arr, mid + 1, right, findVal);
		} else if (findVal < midVal) { // 向左递归
			return binarySearch(arr, left, mid - 1, findVal);
		} else {

			return mid;
		}

	}

	//编写插值查找算法
	//说明：插值查找算法，也要求数组是有序的
	/**
	 * 
	 * @param arr 数组
	 * @param left 左边索引
	 * @param right 右边索引
	 * @param findVal 查找值
	 * @return 如果找到，就返回对应的下标，如果没有找到，返回-1
	 */
	public static int insertValueSearch(int[] arr, int left, int right, int findVal) { 

		System.out.println("插值查找次数~~");
		
		//注意：findVal < arr[0]  和  findVal > arr[arr.length - 1] 必须需要
		//否则我们得到的 mid 可能越界
		if (left > right || findVal < arr[0] || findVal > arr[arr.length - 1]) {
			return -1;
		}

		// 求出mid, 自适应
		int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
		int midVal = arr[mid];
		if (findVal > midVal) { // 说明应该向右边递归
			return insertValueSearch(arr, mid + 1, right, findVal);
		} else if (findVal < midVal) { // 说明向左递归查找
			return insertValueSearch(arr, left, mid - 1, findVal);
		} else {
			return mid;
		}

	}
}

```



### 32.斐波那契查找

>l斐波那契(黄金分割法)查找算法
>
>斐波那契(黄金分割法)原理:
>
>斐波那契查找原理与前两种相似，仅仅
> 改变了中间结点（mid）的位置，mid不
> 再是中间或插值得到，而是位于黄金分
> 割点附近，即mid=low+F(k-1)-1
> （F代表斐波那契数列），如下图所示
>
>![image-20200203163404587]( \img\image-20200203163404587.png)
>
>
>
>对F(k-1)-1的理解：
>
>1)由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1      
>
>
>
>2)类似的，每一子段也可以用相同的方式分割
>
>3)但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。
>
>while(n>fib(k)-1)
>
>  k++;
>
>
>
>

```java

import java.util.Arrays;

public class FibonacciSearch {

	public static int maxSize = 20;
	public static void main(String[] args) {
		int [] arr = {1,8, 10, 89, 1000, 1234};
		
		System.out.println("index=" + fibSearch(arr, 189));// 0
		
	}

	//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列
	//非递归方法得到一个斐波那契数列
	public static int[] fib() {
		int[] f = new int[maxSize];
		f[0] = 1;
		f[1] = 1;
		for (int i = 2; i < maxSize; i++) {
			f[i] = f[i - 1] + f[i - 2];
		}
		return f;
	}
	
	//编写斐波那契查找算法
	//使用非递归的方式编写算法
	/**
	 * 
	 * @param a  数组
	 * @param key 我们需要查找的关键码(值)
	 * @return 返回对应的下标，如果没有-1
	 */
	public static int fibSearch(int[] a, int key) {
		int low = 0;
		int high = a.length - 1;
		int k = 0; //表示斐波那契分割数值的下标
		int mid = 0; //存放mid值
		int f[] = fib(); //获取到斐波那契数列
		//获取到斐波那契分割数值的下标
		while(high > f[k] - 1) {
			k++;
		}
		//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]
		//不足的部分会使用0填充
		int[] temp = Arrays.copyOf(a, f[k]);
		//实际上需求使用a数组最后的数填充 temp
		//举例:
		//temp = {1,8, 10, 89, 1000, 1234, 0, 0}  => {1,8, 10, 89, 1000, 1234, 1234, 1234,}
		for(int i = high + 1; i < temp.length; i++) {
			temp[i] = a[high];
		}
		
		// 使用while来循环处理，找到我们的数 key
		while (low <= high) { // 只要这个条件满足，就可以找
			mid = low + f[k - 1] - 1;
			if(key < temp[mid]) { //我们应该继续向数组的前面查找(左边)
				high = mid - 1;
				//为甚是 k--
				//说明
				//1. 全部元素 = 前面的元素 + 后边元素
				//2. f[k] = f[k-1] + f[k-2]
				//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]
				//即 在 f[k-1] 的前面继续查找 k--
				//即下次循环 mid = f[k-1-1]-1
				k--;
			} else if ( key > temp[mid]) { // 我们应该继续向数组的后面查找(右边)
				low = mid + 1;
				//为什么是k -=2
				//说明
				//1. 全部元素 = 前面的元素 + 后边元素
				//2. f[k] = f[k-1] + f[k-2]
				//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]
				//4. 即在f[k-2] 的前面进行查找 k -=2
				//5. 即下次循环 mid = f[k - 1 - 2] - 1
				k -= 2;
			} else { //找到
				//需要确定，返回的是哪个下标
				if(mid <= high) {
					return mid;
				} else {
					return high;
				}
			}
		}
		return -1;
	}
}

```



### 33.哈希表



> 散列表（Hashtable，也叫哈希表），是根据关键码值(Keyvalue)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 

![image-20200203201710561]( \img\image-20200203201710561.png)

![image-20200203201729273]( \img\image-20200203201729273.png)

>
>
> 要求:
>
>1)不使用数据库,,速度越快越好=>哈希表(散列)
>
>2)添加时，保证按照id从低到高插入[课后思考：如果id不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]
>
>3)使用链表来实现哈希表,该链表不带表头[即:链表的第一个结点就存放雇员信息]4)思路分析并画出示意图 

```java

import java.util.Scanner;

public class HashTabDemo {

	public static void main(String[] args) {
		
		//创建哈希表
		HashTab hashTab = new HashTab(7);
		
		//写一个简单的菜单
		int key = 0;
		Scanner scanner = new Scanner(System.in);
		while(true) {
			System.out.println("1.add:  添加雇员");
			System.out.println("2.list: 显示雇员");
			System.out.println("3.find: 查找雇员");
			System.out.println("4.exit: 退出系统");
			
			key = scanner.nextInt();
			
			switch (key) {
			case 1:
				System.out.println("输入id");
				int id = scanner.nextInt();
				System.out.println("输入名字");
				String name = scanner.next();
				//创建 雇员
				Emp emp = new Emp(id, name);
				hashTab.add(emp);
				break;
			case 2:
				hashTab.list();
				break;
			case 3:
				System.out.println("请输入要查找的id");
				id = scanner.nextInt();
				hashTab.findEmpById(id);
				break;
			case 4:
				scanner.close();
				System.exit(0);
			default:
				break;
			}
		}
		
	}

}

//创建HashTab 管理多条链表
class HashTab {
	private EmpLinkedList[] empLinkedListArray;
	private int size; //表示有多少条链表
	
	//构造器
	public HashTab(int size) {
		this.size = size;
		//初始化empLinkedListArray
		empLinkedListArray = new EmpLinkedList[size];
		//？留一个坑, 这时不要分别初始化每个链表
		for(int i = 0; i < size; i++) {
			empLinkedListArray[i] = new EmpLinkedList();
		}
	}
	
	//添加雇员
	public void add(Emp emp) {
		//根据员工的id ,得到该员工应当添加到哪条链表
		int empLinkedListNO = hashFun(emp.id);
		//将emp 添加到对应的链表中
		empLinkedListArray[empLinkedListNO].add(emp);
		
	}
	//遍历所有的链表,遍历hashtab
	public void list() {
		for(int i = 0; i < size; i++) {
			empLinkedListArray[i].list(i);
		}
	}
	
	//根据输入的id,查找雇员
	public void findEmpById(int id) {
		//使用散列函数确定到哪条链表查找
		int empLinkedListNO = hashFun(id);
		Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);
		if(emp != null) {//找到
			System.out.printf("在第%d条链表中找到 雇员 id = %d\n", (empLinkedListNO + 1), id);
		}else{
			System.out.println("在哈希表中，没有找到该雇员~");
		}
	}
	
	//编写散列函数, 使用一个简单取模法
	public int hashFun(int id) {
		return id % size;
	}
	
	
}

//表示一个雇员
class Emp {
	public int id;
	public String name;
	public Emp next; //next 默认为 null
	public Emp(int id, String name) {
		super();
		this.id = id;
		this.name = name;
	}
}

//创建EmpLinkedList ,表示链表
class EmpLinkedList {
	//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp
	private Emp head; //默认null
	
	//添加雇员到链表
	//说明
	//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大
	//   因此我们将该雇员直接加入到本链表的最后即可
	public void add(Emp emp) {
		//如果是添加第一个雇员
		if(head == null) {
			head = emp;
			return;
		}
		//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后
		Emp curEmp = head;
		while(true) {
			if(curEmp.next == null) {//说明到链表最后
				break;
			}
			curEmp = curEmp.next; //后移
		}
		//退出时直接将emp 加入链表
		curEmp.next = emp;
	}
	
	//遍历链表的雇员信息
	public void list(int no) {
		if(head == null) { //说明链表为空
			System.out.println("第 "+(no+1)+" 链表为空");
			return;
		}
		System.out.print("第 "+(no+1)+" 链表的信息为");
		Emp curEmp = head; //辅助指针
		while(true) {
			System.out.printf(" => id=%d name=%s\t", curEmp.id, curEmp.name);
			if(curEmp.next == null) {//说明curEmp已经是最后结点
				break;
			}
			curEmp = curEmp.next; //后移，遍历
		}
		System.out.println();
	}
	
	//根据id查找雇员
	//如果查找到，就返回Emp, 如果没有找到，就返回null
	public Emp findEmpById(int id) {
		//判断链表是否为空
		if(head == null) {
			System.out.println("链表为空");
			return null;
		}
		//辅助指针
		Emp curEmp = head;
		while(true) {
			if(curEmp.id == id) {//找到
				break;//这时curEmp就指向要查找的雇员
			}
			//退出
			if(curEmp.next == null) {//说明遍历当前链表没有找到该雇员
				curEmp = null;
				break;
			}
			curEmp = curEmp.next;//以后
		}
		
		return curEmp;
	}
	
}


```

### 34.二叉树

>二叉树的遍历说明：
>
>前序遍历：先输出父节点，在遍历左子树和右子树
>
>中序遍历：先遍历左子树，在输出父节点，在遍历右子树
>
>后序遍历：先遍历左子树，在遍历右子树，最后输出父节点
>
>小结：看输出父节点的顺序，就能够确定是前序，中序或者是后序
>
>
>
>1.创建一个二叉树
>
>2.前序遍历：
>
>​	1-先输出当前节点(初始的时候是root节点)
>
>​	2-如果左子节点不为空，则继续前序遍历
>
>​	3-如果右子节点不为空，则继续前序遍历
>
>3.中序遍历：
>
>​	1-如果当前节点的左子节点不为空，则递归中序遍历，输出当前节点
>
>​	2-如果当前节点的右子节点不为空，则递归中序遍历
>
>4.后序遍历：
>
>​	1-如果当前节点的左子节点不为空，则递归后序遍历
>
>​	2-如果当前节点的右子节点不为空，则递归后序遍历，输出当前 节点
>
>

```java


public class BinaryTreeDemo {

	public static void main(String[] args) {
		//先需要创建一颗二叉树
		BinaryTree binaryTree = new BinaryTree();
		//创建需要的结点
		HeroNode root = new HeroNode(1, "宋江");
		HeroNode node2 = new HeroNode(2, "吴用");
		HeroNode node3 = new HeroNode(3, "卢俊义");
		HeroNode node4 = new HeroNode(4, "林冲");
		HeroNode node5 = new HeroNode(5, "关胜");
		
		//说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树
		root.setLeft(node2);
		root.setRight(node3);
		node3.setRight(node4);
		node3.setLeft(node5);
		binaryTree.setRoot(root);
		
		//测试
//		System.out.println("前序遍历"); // 1,2,3,5,4
//		binaryTree.preOrder();
		
		//测试 
//		System.out.println("中序遍历");
//		binaryTree.infixOrder(); // 2,1,5,3,4
//		
//		System.out.println("后序遍历");
//		binaryTree.postOrder(); // 2,5,4,3,1
		
		//前序遍历
		//前序遍历的次数 ：4 
//		System.out.println("前序遍历方式~~~");
//		HeroNode resNode = binaryTree.preOrderSearch(5);
//		if (resNode != null) {
//			System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());
//		} else {
//			System.out.printf("没有找到 no = %d 的英雄", 5);
//		}
		
		//中序遍历查找
		//中序遍历3次
//		System.out.println("中序遍历方式~~~");
//		HeroNode resNode = binaryTree.infixOrderSearch(5);
//		if (resNode != null) {
//			System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());
//		} else {
//			System.out.printf("没有找到 no = %d 的英雄", 5);
//		}
		
		//后序遍历查找
		//后序遍历查找的次数  2次
//		System.out.println("后序遍历方式~~~");
//		HeroNode resNode = binaryTree.postOrderSearch(5);
//		if (resNode != null) {
//			System.out.printf("找到了，信息为 no=%d name=%s", resNode.getNo(), resNode.getName());
//		} else {
//			System.out.printf("没有找到 no = %d 的英雄", 5);
//		}
		
		//测试一把删除结点
		
		System.out.println("删除前,前序遍历");
		binaryTree.preOrder(); //  1,2,3,5,4
		binaryTree.delNode(5);
		//binaryTree.delNode(3);
		System.out.println("删除后，前序遍历");
		binaryTree.preOrder(); // 1,2,3,4
		
		
		
	}

}

//定义BinaryTree 二叉树
class BinaryTree {
	private HeroNode root;

	public void setRoot(HeroNode root) {
		this.root = root;
	}
	
	//删除结点
	public void delNode(int no) {
		if(root != null) {
			//如果只有一个root结点, 这里立即判断root是不是就是要删除结点
			if(root.getNo() == no) {
				root = null;
			} else {
				//递归删除
				root.delNode(no);
			}
		}else{
			System.out.println("空树，不能删除~");
		}
	}
	//前序遍历
	public void preOrder() {
		if(this.root != null) {
			this.root.preOrder();
		}else {
			System.out.println("二叉树为空，无法遍历");
		}
	}
	
	//中序遍历
	public void infixOrder() {
		if(this.root != null) {
			this.root.infixOrder();
		}else {
			System.out.println("二叉树为空，无法遍历");
		}
	}
	//后序遍历
	public void postOrder() {
		if(this.root != null) {
			this.root.postOrder();
		}else {
			System.out.println("二叉树为空，无法遍历");
		}
	}
	
	//前序遍历
	public HeroNode preOrderSearch(int no) {
		if(root != null) {
			return root.preOrderSearch(no);
		} else {
			return null;
		}
	}
	//中序遍历
	public HeroNode infixOrderSearch(int no) {
		if(root != null) {
			return root.infixOrderSearch(no);
		}else {
			return null;
		}
	}
	//后序遍历
	public HeroNode postOrderSearch(int no) {
		if(root != null) {
			return this.root.postOrderSearch(no);
		}else {
			return null;
		}
	}
}

//先创建HeroNode 结点
class HeroNode {
	private int no;
	private String name;
	private HeroNode left; //默认null
	private HeroNode right; //默认null
	public HeroNode(int no, String name) {
		this.no = no;
		this.name = name;
	}
	public int getNo() {
		return no;
	}
	public void setNo(int no) {
		this.no = no;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public HeroNode getLeft() {
		return left;
	}
	public void setLeft(HeroNode left) {
		this.left = left;
	}
	public HeroNode getRight() {
		return right;
	}
	public void setRight(HeroNode right) {
		this.right = right;
	}
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + "]";
	}
	
	//递归删除结点
	//1.如果删除的节点是叶子节点，则删除该节点
	//2.如果删除的节点是非叶子节点，则删除该子树
	public void delNode(int no) {
		
		//思路
		/*
		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.
			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
			5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.

		 */
		//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
		if(this.left != null && this.left.no == no) {
			this.left = null;
			return;
		}
		//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
		if(this.right != null && this.right.no == no) {
			this.right = null;
			return;
		}
		//4.我们就需要向左子树进行递归删除
		if(this.left != null) {
			this.left.delNode(no);
		}
		//5.则应当向右子树进行递归删除
		if(this.right != null) {
			this.right.delNode(no);
		}
	}
	
	//编写前序遍历的方法
	public void preOrder() {
		System.out.println(this); //先输出父结点
		//递归向左子树前序遍历
		if(this.left != null) {
			this.left.preOrder();
		}
		//递归向右子树前序遍历
		if(this.right != null) {
			this.right.preOrder();
		}
	}
	//中序遍历
	public void infixOrder() {
		
		//递归向左子树中序遍历
		if(this.left != null) {
			this.left.infixOrder();
		}
		//输出父结点
		System.out.println(this);
		//递归向右子树中序遍历
		if(this.right != null) {
			this.right.infixOrder();
		}
	}
	//后序遍历
	public void postOrder() {
		if(this.left != null) {
			this.left.postOrder();
		}
		if(this.right != null) {
			this.right.postOrder();
		}
		System.out.println(this);
	}
	
	//前序遍历查找
	/**
	 * 
	 * @param no 查找no
	 * @return 如果找到就返回该Node ,如果没有找到返回 null
	 */
	public HeroNode preOrderSearch(int no) {
		System.out.println("进入前序遍历");
		//比较当前结点是不是
		if(this.no == no) {
			return this;
		}
		//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找
		//2.如果左递归前序查找，找到结点，则返回
		HeroNode resNode = null;
		if(this.left != null) {
			resNode = this.left.preOrderSearch(no);
		}
		if(resNode != null) {//说明我们左子树找到
			return resNode;
		}
		//1.左递归前序查找，找到结点，则返回，否继续判断，
		//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找
		if(this.right != null) {
			resNode = this.right.preOrderSearch(no);
		}
		return resNode;
	}
	
	//中序遍历查找
	public HeroNode infixOrderSearch(int no) {
		//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找
		HeroNode resNode = null;
		if(this.left != null) {
			resNode = this.left.infixOrderSearch(no);
		}
		if(resNode != null) {
			return resNode;
		}
		System.out.println("进入中序查找");
		//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点
		if(this.no == no) {
			return this;
		}
		//否则继续进行右递归的中序查找
		if(this.right != null) {
			resNode = this.right.infixOrderSearch(no);
		}
		return resNode;
		
	}
	
	//后序遍历查找
	public HeroNode postOrderSearch(int no) {
		
		//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找
		HeroNode resNode = null;
		if(this.left != null) {
			resNode = this.left.postOrderSearch(no);
		}
		if(resNode != null) {//说明在左子树找到
			return resNode;
		}
		
		//如果左子树没有找到，则向右子树递归进行后序遍历查找
		if(this.right != null) {
			resNode = this.right.postOrderSearch(no);
		}
		if(resNode != null) {
			return resNode;
		}
		System.out.println("进入后序查找");
		//如果左右子树都没有找到，就比较当前结点是不是
		if(this.no == no) {
			return this;
		}
		return resNode;
	}
	
}

//




```



### 35.顺序存储二叉树

>顺序存储二叉树：
>
>从数据存储来看，**数组存储方式**和**树**
>
>**的存储方式**可以相互转换，即数组可
>
>以转换成树，树也可以转换成数组，
>
>看下边的示意图
>
>
>![image-20200203201729273]( \img\image-20200204173706340.png)
>
>要求:
>
>1)右图的二叉树的结点，要求以数组
> 的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]
>
>2)要求在遍历数组 arr时，仍然可以以
> **前序遍历**，**中序遍历**和**后序遍历**的
> 方式完成结点的遍历
>
>
>
>顺序存储二叉树的**特点**:
>
>1)顺序二叉树通常只考虑完全二叉树
>
>2)第n个元素的左子节点为 2 * n + 1 
>
>3)第n个元素的右子节点为 2 * n + 2
>
>4)第n个元素的父节点为 (n-1) / 2
>
>5)n : 表示二叉树中的第几个元素(按0开始编号
> 如上图所示)
>
>



```java

public class ArrBinaryTreeDemo {

	public static void main(String[] args) {
		int[] arr = { 1, 2, 3, 4, 5, 6, 7 };
		//创建一个 ArrBinaryTree
		ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
		arrBinaryTree.preOrder(); // 1,2,4,5,3,6,7
	}

}

//编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历

class ArrBinaryTree {
	private int[] arr;//存储数据结点的数组

	public ArrBinaryTree(int[] arr) {
		this.arr = arr;
	}
	
	//重载preOrder
	public void preOrder() {
		this.preOrder(0);
	}
	
	//编写一个方法，完成顺序存储二叉树的前序遍历
	/**
	 * 
	 * @param index 数组的下标 
	 */
	public void preOrder(int index) {
		//如果数组为空，或者 arr.length = 0
		if(arr == null || arr.length == 0) {
			System.out.println("数组为空，不能按照二叉树的前序遍历");
		}
		//输出当前这个元素
		System.out.println(arr[index]); 
		//向左递归遍历
		if((index * 2 + 1) < arr.length) {
			preOrder(2 * index + 1 );
		}
		//向右递归遍历
		if((index * 2 + 2) < arr.length) {
			preOrder(2 * index + 2);
		}
	}
	
}

```



### 36.线索化二叉树

>**线索二叉树基本介绍**
>
>
>
>1)n个结点的二叉链表中含有n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向**该**[结](https://baike.baidu.com/item/结点)[点](https://baike.baidu.com/item/结点)在**某种遍历次序**下的前驱和后继结点的指针（这种附加的指针称为"线索"）
>
>
>
>2)这种加上了线索的二叉链表称为**线索链表**，相应的二叉树称为**线索二叉树**(Threaded***BinaryTree**)**。根据线索性质的不同，线索二叉树可分为**前序线索二叉树、中序线索二叉树**和**后序线索二叉树**三种
>
>
>
>3)一个结点的前一个结点，称为**前驱**结点
>
>4)一个结点的后一个结点，称为**后继**结点
>
>![image-20200204221239791]( img\image-20200204221239791.png)
>
>**说明**: **当线索化二叉树后，**Node节点的 属性 **left** **和** **right**，有如下情况:
>
>1)left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.
>
>2)right指向的是右子树，也可能是指向后继节点，比如 ① 节点right 指向的是右子树，而⑩ 节点的right 指向的是后继节点.
>
>

```java

import java.util.concurrent.SynchronousQueue;

public class ThreadedBinaryTreeDemo {

	public static void main(String[] args) {
		//测试一把中序线索二叉树的功能
		HeroNode root = new HeroNode(1, "tom");
		HeroNode node2 = new HeroNode(3, "jack");
		HeroNode node3 = new HeroNode(6, "smith");
		HeroNode node4 = new HeroNode(8, "mary");
		HeroNode node5 = new HeroNode(10, "king");
		HeroNode node6 = new HeroNode(14, "dim");
		
		//二叉树，后面我们要递归创建, 现在简单处理使用手动创建
		root.setLeft(node2);
		root.setRight(node3);
		node2.setLeft(node4);
		node2.setRight(node5);
		node3.setLeft(node6);
		
		//测试中序线索化
		ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree();
		threadedBinaryTree.setRoot(root);
		threadedBinaryTree.threadedNodes();
		
		//测试: 以10号节点测试
		HeroNode leftNode = node5.getLeft();
		HeroNode rightNode = node5.getRight();
		System.out.println("10号结点的前驱结点是 ="  + leftNode); //3
		System.out.println("10号结点的后继结点是="  + rightNode); //1
		
		//当线索化二叉树后，能在使用原来的遍历方法
		//threadedBinaryTree.infixOrder();
		System.out.println("使用线索化的方式遍历 线索化二叉树");
		threadedBinaryTree.threadedList(); // 8, 3, 10, 1, 14, 6
		
	}

}




//定义ThreadedBinaryTree 实现了线索化功能的二叉树
class ThreadedBinaryTree {
	private HeroNode root;
	
	//为了实现线索化，需要创建要给指向当前结点的前驱结点的指针
	//在递归进行线索化时，pre 总是保留前一个结点
	private HeroNode pre = null;

	public void setRoot(HeroNode root) {
		this.root = root;
	}
	
	//重载一把threadedNodes方法
	public void threadedNodes() {
		this.threadedNodes(root);
	}
	
	//遍历线索化二叉树的方法
	public void threadedList() {
		//定义一个变量，存储当前遍历的结点，从root开始
		HeroNode node = root;
		while(node != null) {
			//循环的找到leftType == 1的结点，第一个找到就是8结点
			//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化
			//处理后的有效结点
			while(node.getLeftType() == 0) {
				node = node.getLeft();
			}
			
			//打印当前这个结点
			System.out.println(node);
			//如果当前结点的右指针指向的是后继结点,就一直输出
			while(node.getRightType() == 1) {
				//获取到当前结点的后继结点
				node = node.getRight();
				System.out.println(node);
			}
			//替换这个遍历的结点
			node = node.getRight();
			
		}
	}
	
	//编写对二叉树进行中序线索化的方法
	/**
	 * 
	 * @param node 就是当前需要线索化的结点
	 */
	public void threadedNodes(HeroNode node) {
		
		//如果node==null, 不能线索化
		if(node == null) {
			return;
		}
		
		//(一)先线索化左子树
		threadedNodes(node.getLeft());
		//(二)线索化当前结点[有难度]
		
		//处理当前结点的前驱结点
		//以8结点来理解
		//8结点的.left = null , 8结点的.leftType = 1
		if(node.getLeft() == null) {
			//让当前结点的左指针指向前驱结点 
			node.setLeft(pre); 
			//修改当前结点的左指针的类型,指向前驱结点
			node.setLeftType(1);
		}
		
		//处理后继结点
		if (pre != null && pre.getRight() == null) {
			//让前驱结点的右指针指向当前结点
			pre.setRight(node);
			//修改前驱结点的右指针类型
			pre.setRightType(1);
		}
		//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点
		pre = node;
		
		//(三)在线索化右子树
		threadedNodes(node.getRight());
		
		
	}
	
	//删除结点
	public void delNode(int no) {
		if(root != null) {
			//如果只有一个root结点, 这里立即判断root是不是就是要删除结点
			if(root.getNo() == no) {
				root = null;
			} else {
				//递归删除
				root.delNode(no);
			}
		}else{
			System.out.println("空树，不能删除~");
		}
	}
	//前序遍历
	public void preOrder() {
		if(this.root != null) {
			this.root.preOrder();
		}else {
			System.out.println("二叉树为空，无法遍历");
		}
	}
	
	//中序遍历
	public void infixOrder() {
		if(this.root != null) {
			this.root.infixOrder();
		}else {
			System.out.println("二叉树为空，无法遍历");
		}
	}
	//后序遍历
	public void postOrder() {
		if(this.root != null) {
			this.root.postOrder();
		}else {
			System.out.println("二叉树为空，无法遍历");
		}
	}
	
	//前序遍历
	public HeroNode preOrderSearch(int no) {
		if(root != null) {
			return root.preOrderSearch(no);
		} else {
			return null;
		}
	}
	//中序遍历
	public HeroNode infixOrderSearch(int no) {
		if(root != null) {
			return root.infixOrderSearch(no);
		}else {
			return null;
		}
	}
	//后序遍历
	public HeroNode postOrderSearch(int no) {
		if(root != null) {
			return this.root.postOrderSearch(no);
		}else {
			return null;
		}
	}
}

//先创建HeroNode 结点
class HeroNode {
	private int no;
	private String name;
	private HeroNode left; //默认null
	private HeroNode right; //默认null
	//说明
	//1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点
	//2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点
	private int leftType;
	private int rightType;
	
	
	
	public int getLeftType() {
		return leftType;
	}
	public void setLeftType(int leftType) {
		this.leftType = leftType;
	}
	public int getRightType() {
		return rightType;
	}
	public void setRightType(int rightType) {
		this.rightType = rightType;
	}
	public HeroNode(int no, String name) {
		this.no = no;
		this.name = name;
	}
	public int getNo() {
		return no;
	}
	public void setNo(int no) {
		this.no = no;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public HeroNode getLeft() {
		return left;
	}
	public void setLeft(HeroNode left) {
		this.left = left;
	}
	public HeroNode getRight() {
		return right;
	}
	public void setRight(HeroNode right) {
		this.right = right;
	}
	@Override
	public String toString() {
		return "HeroNode [no=" + no + ", name=" + name + "]";
	}
	
	//递归删除结点
	//1.如果删除的节点是叶子节点，则删除该节点
	//2.如果删除的节点是非叶子节点，则删除该子树
	public void delNode(int no) {
		
		//思路
		/*
		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.
			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除
			5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.

		 */
		//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)
		if(this.left != null && this.left.no == no) {
			this.left = null;
			return;
		}
		//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)
		if(this.right != null && this.right.no == no) {
			this.right = null;
			return;
		}
		//4.我们就需要向左子树进行递归删除
		if(this.left != null) {
			this.left.delNode(no);
		}
		//5.则应当向右子树进行递归删除
		if(this.right != null) {
			this.right.delNode(no);
		}
	}
	
	//编写前序遍历的方法
	public void preOrder() {
		System.out.println(this); //先输出父结点
		//递归向左子树前序遍历
		if(this.left != null) {
			this.left.preOrder();
		}
		//递归向右子树前序遍历
		if(this.right != null) {
			this.right.preOrder();
		}
	}
	//中序遍历
	public void infixOrder() {
		
		//递归向左子树中序遍历
		if(this.left != null) {
			this.left.infixOrder();
		}
		//输出父结点
		System.out.println(this);
		//递归向右子树中序遍历
		if(this.right != null) {
			this.right.infixOrder();
		}
	}
	//后序遍历
	public void postOrder() {
		if(this.left != null) {
			this.left.postOrder();
		}
		if(this.right != null) {
			this.right.postOrder();
		}
		System.out.println(this);
	}
	
	//前序遍历查找
	/**
	 * 
	 * @param no 查找no
	 * @return 如果找到就返回该Node ,如果没有找到返回 null
	 */
	public HeroNode preOrderSearch(int no) {
		System.out.println("进入前序遍历");
		//比较当前结点是不是
		if(this.no == no) {
			return this;
		}
		//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找
		//2.如果左递归前序查找，找到结点，则返回
		HeroNode resNode = null;
		if(this.left != null) {
			resNode = this.left.preOrderSearch(no);
		}
		if(resNode != null) {//说明我们左子树找到
			return resNode;
		}
		//1.左递归前序查找，找到结点，则返回，否继续判断，
		//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找
		if(this.right != null) {
			resNode = this.right.preOrderSearch(no);
		}
		return resNode;
	}
	
	//中序遍历查找
	public HeroNode infixOrderSearch(int no) {
		//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找
		HeroNode resNode = null;
		if(this.left != null) {
			resNode = this.left.infixOrderSearch(no);
		}
		if(resNode != null) {
			return resNode;
		}
		System.out.println("进入中序查找");
		//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点
		if(this.no == no) {
			return this;
		}
		//否则继续进行右递归的中序查找
		if(this.right != null) {
			resNode = this.right.infixOrderSearch(no);
		}
		return resNode;
		
	}
	
	//后序遍历查找
	public HeroNode postOrderSearch(int no) {
		
		//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找
		HeroNode resNode = null;
		if(this.left != null) {
			resNode = this.left.postOrderSearch(no);
		}
		if(resNode != null) {//说明在左子树找到
			return resNode;
		}
		
		//如果左子树没有找到，则向右子树递归进行后序遍历查找
		if(this.right != null) {
			resNode = this.right.postOrderSearch(no);
		}
		if(resNode != null) {
			return resNode;
		}
		System.out.println("进入后序查找");
		//如果左右子树都没有找到，就比较当前结点是不是
		if(this.no == no) {
			return this;
		}
		return resNode;
	}
	
}

```



### 37.堆排序

>
>
> 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
>
>2)堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆,注意:没有要求结点的左孩子的值和右孩子的值的大小关系。
>
>3)每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆
>
>4)大顶堆举例说明 
>
>![image-20200206162646228](img\image-20200206162646228.png)
>
> 5)小顶堆举例说明 
>
>![image-20200206162726752](img\image-20200206162726752.png)
>
> 6)一般升序采用大顶堆，降序采用小顶堆 
>
> 堆排序的基本思想是：
>
>1)将待排序序列构造成一个大顶堆
>
>2)此时，整个序列的最大值就是堆顶的根节点。
>
>3)将其与末尾元素进行交换，此时末尾就为最大值。
>
>4)然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。
>
>如此反复执行，便能得到一个有序序列了。可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了
>
>
>
>

```java


import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class HeapSort {

	public static void main(String[] args) {
		//要求将数组进行升序排序
		//int arr[] = {4, 6, 8, 5, 9};
		// 创建要给80000个的随机的数组
		int[] arr = new int[8000000];
		for (int i = 0; i < 8000000; i++) {
			arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
		}

		System.out.println("排序前");
		Date data1 = new Date();
		SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		String date1Str = simpleDateFormat.format(data1);
		System.out.println("排序前的时间是=" + date1Str);
		
		heapSort(arr);
		
		Date data2 = new Date();
		String date2Str = simpleDateFormat.format(data2);
		System.out.println("排序前的时间是=" + date2Str);
		//System.out.println("排序后=" + Arrays.toString(arr));
	}

	//编写一个堆排序的方法
	public static void heapSort(int arr[]) {
		int temp = 0;
		System.out.println("堆排序!!");
		
//		//分步完成
//		adjustHeap(arr, 1, arr.length);
//		System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6
//		
//		adjustHeap(arr, 0, arr.length);
//		System.out.println("第2次" + Arrays.toString(arr)); // 9,6,8,5,4
		
		//完成我们最终代码
		//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
		for(int i = arr.length / 2 -1; i >=0; i--) {
			adjustHeap(arr, i, arr.length);
		}
		
		/*
		 * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
　　			3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
		 */
		for(int j = arr.length-1;j >0; j--) {
			//交换
			temp = arr[j];
			arr[j] = arr[0];
			arr[0] = temp;
			adjustHeap(arr, 0, j); 
		}
		
		//System.out.println("数组=" + Arrays.toString(arr)); 
		
	}
	
	//将一个数组(二叉树), 调整成一个大顶堆
	/**
	 * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆
	 * 举例  int arr[] = {4, 6, 8, 5, 9}; => i = 1 => adjustHeap => 得到 {4, 9, 8, 5, 6}
	 * 如果我们再次调用  adjustHeap 传入的是 i = 0 => 得到 {4, 9, 8, 5, 6} => {9,6,8,5, 4}
	 * @param arr 待调整的数组
	 * @param i 表示非叶子结点在数组中索引
	 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少
	 */
	public  static void adjustHeap(int arr[], int i, int lenght) {
		
		int temp = arr[i];//先取出当前元素的值，保存在临时变量
		//开始调整
		//说明
		//1. k = i * 2 + 1 k 是 i结点的左子结点
		for(int k = i * 2 + 1; k < lenght; k = k * 2 + 1) {
			if(k+1 < lenght && arr[k] < arr[k+1]) { //说明左子结点的值小于右子结点的值
				k++; // k 指向右子结点
			}
			if(arr[k] > temp) { //如果子结点大于父结点
				arr[i] = arr[k]; //把较大的值赋给当前结点
				i = k; //!!! i 指向 k,继续循环比较
			} else {
				break;//!
			}
		}
		//当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)
		arr[i] = temp;//将temp值放到调整后的位置
	}
	
}

```



### 38.赫夫曼树

>赫夫曼树介绍：
>
> 1)给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(HuffmanTree),还有的书翻译为霍夫曼树。
>
>2)赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近 
>
>
>
>赫夫曼树几个重要概念：
>
> 1)路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路 
>
> 中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1
>
>2)结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积
>
>3)树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weightedpathlength),权值越大的结点离根结点越近的二叉树才是最优二叉树。
>
>4)WPL最小的就是赫夫曼树 
>
>
>
> 构成赫夫曼树的步骤：
>
>1)从小到大进行排序,将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树
>
>2)取出根节点权值最小的两颗二叉树
>
>3)组成一颗新的二叉树,该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 
>
> 4)再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树
>
>5)图解: 
>
>![image-20200207141816547](img\image-20200207141816547.png)
>
>
>
>
>
>
>
>



~~~java


import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class HuffmanCode {

	public static void main(String[] args) {
		
		//测试压缩文件
//		String srcFile = "d://Uninstall.xml";
//		String dstFile = "d://Uninstall.zip";
//		
//		zipFile(srcFile, dstFile);
//		System.out.println("压缩文件ok~~");
		
		
		//测试解压文件
		String zipFile = "d://Uninstall.zip";
		String dstFile = "d://Uninstall2.xml";
		unZipFile(zipFile, dstFile);
		System.out.println("解压成功!");
		
		/*
		String content = "i like like like java do you like a java";
		byte[] contentBytes = content.getBytes();
		System.out.println(contentBytes.length); //40
		
		byte[] huffmanCodesBytes= huffmanZip(contentBytes);
		System.out.println("压缩后的结果是:" + Arrays.toString(huffmanCodesBytes) + " 长度= " + huffmanCodesBytes.length);
		
		
		//测试一把byteToBitString方法
		//System.out.println(byteToBitString((byte)1));
		byte[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes);
		
		System.out.println("原来的字符串=" + new String(sourceBytes)); // "i like like like java do you like a java"
		*/
		
		
		
		//如何将 数据进行解压(解码)  
		//分步过程
		/*
		List<Node> nodes = getNodes(contentBytes);
		System.out.println("nodes=" + nodes);
		
		//测试一把，创建的赫夫曼树
		System.out.println("赫夫曼树");
		Node huffmanTreeRoot = createHuffmanTree(nodes);
		System.out.println("前序遍历");
		huffmanTreeRoot.preOrder();
		
		//测试一把是否生成了对应的赫夫曼编码
		Map<Byte, String> huffmanCodes = getCodes(huffmanTreeRoot);
		System.out.println("~生成的赫夫曼编码表= " + huffmanCodes);
		
		//测试
		byte[] huffmanCodeBytes = zip(contentBytes, huffmanCodes);
		System.out.println("huffmanCodeBytes=" + Arrays.toString(huffmanCodeBytes));//17
		
		//发送huffmanCodeBytes 数组 */
		
		
	}
	
	//编写一个方法，完成对压缩文件的解压
	/**
	 * 
	 * @param zipFile 准备解压的文件
	 * @param dstFile 将文件解压到哪个路径
	 */
	public static void unZipFile(String zipFile, String dstFile) {
		
		//定义文件输入流
		InputStream is = null;
		//定义一个对象输入流
		ObjectInputStream ois = null;
		//定义文件的输出流
		OutputStream os = null;
		try {
			//创建文件输入流
			is = new FileInputStream(zipFile);
			//创建一个和  is关联的对象输入流
			ois = new ObjectInputStream(is);
			//读取byte数组  huffmanBytes
			byte[] huffmanBytes = (byte[])ois.readObject();
			//读取赫夫曼编码表
			Map<Byte,String> huffmanCodes = (Map<Byte,String>)ois.readObject();
			
			//解码
			byte[] bytes = decode(huffmanCodes, huffmanBytes);
			//将bytes 数组写入到目标文件
			os = new FileOutputStream(dstFile);
			//写数据到 dstFile 文件
			os.write(bytes);
		} catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		} finally {
			
			try {
				os.close();
				ois.close();
				is.close();
			} catch (Exception e2) {
				// TODO: handle exception
				System.out.println(e2.getMessage());
			}
			
		}
	}
	
	//编写方法，将一个文件进行压缩
	/**
	 * 
	 * @param srcFile 你传入的希望压缩的文件的全路径
	 * @param dstFile 我们压缩后将压缩文件放到哪个目录
	 */
	public static void zipFile(String srcFile, String dstFile) {
		
		//创建输出流
		OutputStream os = null;
		ObjectOutputStream oos = null;
		//创建文件的输入流
		FileInputStream is = null;
		try {
			//创建文件的输入流
			is = new FileInputStream(srcFile);
			//创建一个和源文件大小一样的byte[]
			byte[] b = new byte[is.available()];
			//读取文件
			is.read(b);
			//直接对源文件压缩
			byte[] huffmanBytes = huffmanZip(b);
			//创建文件的输出流, 存放压缩文件
			os = new FileOutputStream(dstFile);
			//创建一个和文件输出流关联的ObjectOutputStream
			oos = new ObjectOutputStream(os);
			//把 赫夫曼编码后的字节数组写入压缩文件
			oos.writeObject(huffmanBytes); //我们是把
			//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用
			//注意一定要把赫夫曼编码 写入压缩文件
			oos.writeObject(huffmanCodes);
			
			
		}catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		}finally {
			try {
				is.close();
				oos.close();
				os.close();
			}catch (Exception e) {
				// TODO: handle exception
				System.out.println(e.getMessage());
			}
		}
		
	}
	
	//完成数据的解压
	//思路
	//1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]
	//   重写先转成 赫夫曼编码对应的二进制的字符串 "1010100010111..."
	//2.  赫夫曼编码对应的二进制的字符串 "1010100010111..." =》 对照 赫夫曼编码  =》 "i like like like java do you like a java"
	
	
	//编写一个方法，完成对压缩数据的解码
	/**
	 * 
	 * @param huffmanCodes 赫夫曼编码表 map
	 * @param huffmanBytes 赫夫曼编码得到的字节数组
	 * @return 就是原来的字符串对应的数组
	 */
	private static byte[] decode(Map<Byte,String> huffmanCodes, byte[] huffmanBytes) {
		
		//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...
		StringBuilder stringBuilder = new StringBuilder();
		//将byte数组转成二进制的字符串
		for(int i = 0; i < huffmanBytes.length; i++) {
			byte b = huffmanBytes[i];
			//判断是不是最后一个字节
			boolean flag = (i == huffmanBytes.length - 1);
			stringBuilder.append(byteToBitString(!flag, b));
		}
		//把字符串安装指定的赫夫曼编码进行解码
		//把赫夫曼编码表进行调换，因为反向查询 a->100 100->a
		Map<String, Byte>  map = new HashMap<String,Byte>();
		for(Map.Entry<Byte, String> entry: huffmanCodes.entrySet()) {
			map.put(entry.getValue(), entry.getKey());
		}
		
		//创建要给集合，存放byte
		List<Byte> list = new ArrayList<>();
		//i 可以理解成就是索引,扫描 stringBuilder 
		for(int  i = 0; i < stringBuilder.length(); ) {
			int count = 1; // 小的计数器
			boolean flag = true;
			Byte b = null;
			
			while(flag) {
				//1010100010111...
				//递增的取出 key 1 
				String key = stringBuilder.substring(i, i+count);//i 不动，让count移动，指定匹配到一个字符
				b = map.get(key);
				if(b == null) {//说明没有匹配到
					count++;
				}else {
					//匹配到
					flag = false;
				}
			}
			list.add(b);
			i += count;//i 直接移动到 count	
		}
		//当for循环结束后，我们list中就存放了所有的字符  "i like like like java do you like a java"
		//把list 中的数据放入到byte[] 并返回
		byte b[] = new byte[list.size()];
		for(int i = 0;i < b.length; i++) {
			b[i] = list.get(i);
		}
		return b;
		
	}
 	
	/**
	 * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码
	 * @param b 传入的 byte
	 * @param flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位
	 * @return 是该b 对应的二进制的字符串，（注意是按补码返回）
	 */
	private static String byteToBitString(boolean flag, byte b) {
		//使用变量保存 b
		int temp = b; //将 b 转成 int
		//如果是正数我们还存在补高位
		if(flag) {
			temp |= 256; //按位与 256  1 0000 0000  | 0000 0001 => 1 0000 0001
		}
		String str = Integer.toBinaryString(temp); //返回的是temp对应的二进制的补码
		if(flag) {
			return str.substring(str.length() - 8);
		} else {
			return str;
		}
	}
	
	//使用一个方法，将前面的方法封装起来，便于我们的调用.
	/**
	 * 
	 * @param bytes 原始的字符串对应的字节数组
	 * @return 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)
	 */
	private static byte[] huffmanZip(byte[] bytes) {
		List<Node> nodes = getNodes(bytes);
		//根据 nodes 创建的赫夫曼树
		Node huffmanTreeRoot = createHuffmanTree(nodes);
		//对应的赫夫曼编码(根据 赫夫曼树)
		Map<Byte, String> huffmanCodes = getCodes(huffmanTreeRoot);
		//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组
		byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);
		return huffmanCodeBytes;
	}
	
	
	//编写一个方法，将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]
	/**
	 * 
	 * @param bytes 这时原始的字符串对应的 byte[]
	 * @param huffmanCodes 生成的赫夫曼编码map
	 * @return 返回赫夫曼编码处理后的 byte[] 
	 * 举例： String content = "i like like like java do you like a java"; =》 byte[] contentBytes = content.getBytes();
	 * 返回的是 字符串 "1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100"
	 * => 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes
	 * huffmanCodeBytes[0] =  10101000(补码) => byte  [推导  10101000=> 10101000 - 1 => 10100111(反码)=> 11011000= -88 ]
	 * huffmanCodeBytes[1] = -88
	 */
	private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
		
		//1.利用 huffmanCodes 将  bytes 转成  赫夫曼编码对应的字符串
		StringBuilder stringBuilder = new StringBuilder();
		//遍历bytes 数组 
		for(byte b: bytes) {
			stringBuilder.append(huffmanCodes.get(b));
		}
		
		//System.out.println("测试 stringBuilder~~~=" + stringBuilder.toString());
		
		//将 "1010100010111111110..." 转成 byte[]
		
		//统计返回  byte[] huffmanCodeBytes 长度
		//一句话 int len = (stringBuilder.length() + 7) / 8;
		int len;
		if(stringBuilder.length() % 8 == 0) {
			len = stringBuilder.length() / 8;
		} else {
			len = stringBuilder.length() / 8 + 1;
		}
		//创建 存储压缩后的 byte数组
		byte[] huffmanCodeBytes = new byte[len];
		int index = 0;//记录是第几个byte
		for (int i = 0; i < stringBuilder.length(); i += 8) { //因为是每8位对应一个byte,所以步长 +8
				String strByte;
				if(i+8 > stringBuilder.length()) {//不够8位
					strByte = stringBuilder.substring(i);
				}else{
					strByte = stringBuilder.substring(i, i + 8);
				}	
				//将strByte 转成一个byte,放入到 huffmanCodeBytes
				huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2);
				index++;
		}
		return huffmanCodeBytes;
	}
	
	//生成赫夫曼树对应的赫夫曼编码
	//思路:
	//1. 将赫夫曼编码表存放在 Map<Byte,String> 形式
	//   生成的赫夫曼编码表{32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011}
	static Map<Byte, String> huffmanCodes = new HashMap<Byte,String>();
	//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径
	static StringBuilder stringBuilder = new StringBuilder();
	
	
	//为了调用方便，我们重载 getCodes
	private static Map<Byte, String> getCodes(Node root) {
		if(root == null) {
			return null;
		}
		//处理root的左子树
		getCodes(root.left, "0", stringBuilder);
		//处理root的右子树
		getCodes(root.right, "1", stringBuilder);
		return huffmanCodes;
	}
	
	/**
	 * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合
	 * @param node  传入结点
	 * @param code  路径： 左子结点是 0, 右子结点 1
	 * @param stringBuilder 用于拼接路径
	 */
	private static void getCodes(Node node, String code, StringBuilder stringBuilder) {
		StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
		//将code 加入到 stringBuilder2
		stringBuilder2.append(code);
		if(node != null) { //如果node == null不处理
			//判断当前node 是叶子结点还是非叶子结点
			if(node.data == null) { //非叶子结点
				//递归处理
				//向左递归
				getCodes(node.left, "0", stringBuilder2);
				//向右递归
				getCodes(node.right, "1", stringBuilder2);
			} else { //说明是一个叶子结点
				//就表示找到某个叶子结点的最后
				huffmanCodes.put(node.data, stringBuilder2.toString());
			}
		}
	}
	
	//前序遍历的方法
	private static void preOrder(Node root) {
		if(root != null) {
			root.preOrder();
		}else {
			System.out.println("赫夫曼树为空");
		}
	}
	
	/**
	 * 
	 * @param bytes 接收字节数组
	 * @return 返回的就是 List 形式   [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],
	 */
	private static List<Node> getNodes(byte[] bytes) {
		
		//1创建一个ArrayList
		ArrayList<Node> nodes = new ArrayList<Node>();
		
		//遍历 bytes , 统计 每一个byte出现的次数->map[key,value]
		Map<Byte, Integer> counts = new HashMap<>();
		for (byte b : bytes) {
			Integer count = counts.get(b);
			if (count == null) { // Map还没有这个字符数据,第一次
				counts.put(b, 1);
			} else {
				counts.put(b, count + 1);
			}
		}
		
		//把每一个键值对转成一个Node 对象，并加入到nodes集合
		//遍历map
		for(Map.Entry<Byte, Integer> entry: counts.entrySet()) {
			nodes.add(new Node(entry.getKey(), entry.getValue()));
		}
		return nodes;
		
	}
	
	//可以通过List 创建对应的赫夫曼树
	private static Node createHuffmanTree(List<Node> nodes) {
		
		while(nodes.size() > 1) {
			//排序, 从小到大
			Collections.sort(nodes);
			//取出第一颗最小的二叉树
			Node leftNode = nodes.get(0);
			//取出第二颗最小的二叉树
			Node rightNode = nodes.get(1);
			//创建一颗新的二叉树,它的根节点 没有data, 只有权值
			Node parent = new Node(null, leftNode.weight + rightNode.weight);
			parent.left = leftNode;
			parent.right = rightNode;
			
			//将已经处理的两颗二叉树从nodes删除
			nodes.remove(leftNode);
			nodes.remove(rightNode);
			//将新的二叉树，加入到nodes
			nodes.add(parent);
			
		}
		//nodes 最后的结点，就是赫夫曼树的根结点
		return nodes.get(0);
		
	}
	

}



//创建Node ,待数据和权值
class Node implements Comparable<Node>  {
	Byte data; // 存放数据(字符)本身，比如'a' => 97 ' ' => 32
	int weight; //权值, 表示字符出现的次数
	Node left;//
	Node right;
	public Node(Byte data, int weight) {
		
		this.data = data;
		this.weight = weight;
	}
	@Override
	public int compareTo(Node o) {
		// 从小到大排序
		return this.weight - o.weight;
	}
	
	public String toString() {
		return "Node [data = " + data + " weight=" + weight + "]";
	}
	
	//前序遍历
	public void preOrder() {
		System.out.println(this);
		if(this.left != null) {
			this.left.preOrder();
		}
		if(this.right != null) {
			this.right.preOrder();
		}
	}
}

~~~



### 39.图

~~~java
package graph;

import java.util.ArrayList;
import java.util.Arrays;

public class Graph {

	private ArrayList<String> vertexList;// 存储顶点集合
	private int[][] edges;// 存储图的邻接矩阵
	private int numOfEdges;// 表示边的数目

	public static void main(String[] args) {

		//测试一遍图是否创建ok
		int n = 5;//节点的个数
		String VertexValue[]= {"A","B","C","D","E"};
		//创建图对象
		Graph graph = new Graph(n);
		for(String value:VertexValue){
			graph.insertVertex(value);
		}
		
		//添加边 A-B A-C B-C B-D B-E
		graph.insertEdge(0,1,1);
		graph.insertEdge(0,2,1);
		graph.insertEdge(1,2,1);
		graph.insertEdge(1,3,1);
		graph.insertEdge(1,4,1);
		
		graph.showGraph();
		
		
	}

	// 构造器
	public Graph(int n) {
		// 初始化矩阵和vertexList
		edges = new int[n][n];
		vertexList = new ArrayList<String>(n);
		numOfEdges = 0;
	}
	
	//图中常用的方法
	//返回节点的个数
	public int getNumOfVertex(){
		return vertexList.size();
	}
	
	//显示图对应的矩阵
	public void showGraph(){
		for(int link[]:edges){
			System.out.println(Arrays.toString(link));
		}
	}
	
	//得到边的数目
	public int getNumOfEdges(){
		return numOfEdges;
	}
	
	//返回节点i(下标)对应的数据 0->A , 1->B
	public String getValueByIndex(int i){
		return vertexList.get(i);
	}
	
	//返回 v1 和 v2 的权值
	public int getWeight(int v1,int v2){
		return edges[v1][v2];
	}
	
	
	
	

	// 插入节点
	public void insertVertex(String vertex) {
		vertexList.add(vertex);
	}

	/**
	 * @param v1	  表示点的下标即 是第几个顶点
	 * @param v2	  第二个顶点对应的下标
	 * @param weight 表示权值
	 */
	public void insertEdge(int v1, int v2, int weight) {
		edges[v1][v2] = weight;
		edges[v2][v1] = weight;
		numOfEdges++;
	}

}

~~~



### 40.图的深度优先遍历 DFS

~~~java
package graph;

import java.util.ArrayList;
import java.util.Arrays;

public class Graph {

	private ArrayList<String> vertexList;// 存储顶点集合
	private int[][] edges;// 存储图的邻接矩阵
	private int numOfEdges;// 表示边的数目
	// 定义一个数组boolean[],记录某个节点是否被访问
	private boolean isVisited[];

	public static void main(String[] args) {

		// 测试一遍图是否创建ok
		int n = 5;// 节点的个数
		String VertexValue[] = { "A", "B", "C", "D", "E" };
		// 创建图对象
		Graph graph = new Graph(n);
		for (String value : VertexValue) {
			graph.insertVertex(value);
		}

		// 添加边 A-B A-C B-C B-D B-E
		graph.insertEdge(0, 1, 1);
		graph.insertEdge(0, 2, 1);
		graph.insertEdge(1, 2, 1);
		graph.insertEdge(1, 3, 1);
		graph.insertEdge(1, 4, 1);

		graph.showGraph();

		System.out.println("深度遍历");
		graph.dfs();

	}

	// 构造器
	public Graph(int n) {
		// 初始化矩阵和vertexList
		edges = new int[n][n];
		vertexList = new ArrayList<String>(n);
		numOfEdges = 0;
		isVisited = new boolean[n];
	}

	// 得到第一个邻接节点的下标w
	/**
	 * @param index
	 * @return 如果存在就返回对应的下标，否则返回 -1
	 */
	public int getFirstNeighbor(int index) {
		for (int j = 0; j < vertexList.size(); j++) {
			if (edges[index][j] > 0) {
				return j;
			}
		}

		return -1;
	}

	// 根据前一个邻接节点的下标来获取下一个邻接节点
	public int getNextNeighbor(int v1, int v2) {

		for (int j = v2 + 1; j < vertexList.size(); j++) {
			if (edges[v1][j] > 0) {
				return j;
			}
		}

		return -1;
	}

	// 深度优先遍历算法
	private void dfs(boolean[] isVisited, int i) {
		// 首先我们访问该节点，输出
		System.out.print(getValueByIndex(i) + "->");
		// 将节点设置为已经访问过的
		isVisited[i] = true;
		// 查找节点i的第一个邻接节点w
		int w = getFirstNeighbor(i);
		while (w != -1) {// 说明有
			if (!isVisited[w]) {
				dfs(isVisited, w);
			}
			// 如果节点w已经被访问过
			w = getNextNeighbor(i, w);
		}

	}

	// 对 dfs 进行一个重载，遍历我们所有节点，并进行 dfs
	public void dfs() {
		// 遍历所有的节点，进行 dfs[回溯]
		for (int i = 0; i < getNumOfVertex(); i++) {
			if (!isVisited[i]) {
				dfs(isVisited, i);
			}
		}
	}

	// 图中常用的方法
	// 返回节点的个数
	public int getNumOfVertex() {
		return vertexList.size();
	}

	// 显示图对应的矩阵
	public void showGraph() {
		for (int link[] : edges) {
			System.out.println(Arrays.toString(link));
		}
	}

	// 得到边的数目
	public int getNumOfEdges() {
		return numOfEdges;
	}

	// 返回节点i(下标)对应的数据 0->A , 1->B
	public String getValueByIndex(int i) {
		return vertexList.get(i);
	}

	// 返回 v1 和 v2 的权值
	public int getWeight(int v1, int v2) {
		return edges[v1][v2];
	}

	// 插入节点
	public void insertVertex(String vertex) {
		vertexList.add(vertex);
	}

	/**
	 * @param v1
	 *            表示点的下标即 是第几个顶点
	 * @param v2
	 *            第二个顶点对应的下标
	 * @param weight
	 *            表示权值
	 */
	public void insertEdge(int v1, int v2, int weight) {
		edges[v1][v2] = weight;
		edges[v2][v1] = weight;
		numOfEdges++;
	}

}

~~~



## 程序员常用的十种算法

### 41.二分查找(非递归)

~~~java
public class BinarySearch {
	public static void main(String[] args) {

		int arr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
		System.out.println(binarySearch(arr, 5));
	}

	/**
	 * @param arr
	 *            待查找的数组，arr是升序排列
	 * @param target
	 *            需要查找的数
	 * @return 返回对应的下标，-1表示没有找到
	 */
	public static int binarySearch(int[] arr, int target) {
		int left = 0;
		int right = arr.length - 1;
		while (left <= right) {// 说明继续查找
			int mid = (left + right) / 2;
			if (arr[mid] == target) {
				return mid;
			} else if (arr[mid] > target) {
				right = mid - 1;
			} else if (arr[mid] < target) {
				left = mid + 1;
			}

		}
		return -1;

	}
}

~~~





### 42.分治算法(汉诺塔)

~~~java
public class HanoTower {
	public static void main(String[] args) {
		hanoTower(5, 'A', 'B', 'C');
	}

	public static void hanoTower(int num, char a, char b, char c) {
		// 如果只有一个盘
		if (num == 1) {
			System.out.println("第1个盘从" + a + "->" + c);
		} else {
			// 如果我们有 n >= 2 的情况，我们总是可以看做是两个盘
			// 1.最下边一个盘 2.上面的所有盘
			// 1.先把最上面所有盘A->B，移动过程中会用到C塔
			hanoTower(num - 1, a, c, b);
			// 2.把最下面的盘A->C
			System.out.println("第" + num + "个盘从" + a + "->" + c);
			// 3.把B塔的所有盘 从 B->C，移动过程中使用到A塔
			hanoTower(num - 1, b, a, c);
		}

	}
}

~~~



### 43.动态规划

~~~java

public class KnapsackProblem {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int[] w = {1, 4, 3};//物品的重量
		int[] val = {1500, 3000, 2000}; //物品的价值 这里val[i] 就是前面讲的v[i]
		int m = 4; //背包的容量
		int n = val.length; //物品的个数
		
		
		
		//创建二维数组，
		//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值
		int[][] v = new int[n+1][m+1];
		//为了记录放入商品的情况，我们定一个二维数组
		int[][] path = new int[n+1][m+1];
		
		//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0
		for(int i = 0; i < v.length; i++) {
			v[i][0] = 0; //将第一列设置为0
		}
		for(int i=0; i < v[0].length; i++) {
			v[0][i] = 0; //将第一行设置0
		}
		
		
		//根据前面得到公式来动态规划处理
		for(int i = 1; i < v.length; i++) { //不处理第一行 i是从1开始的
			for(int j=1; j < v[0].length; j++) {//不处理第一列, j是从1开始的
				//公式
				if(w[i-1]> j) { // 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]
					v[i][j]=v[i-1][j];
				} else {
					//说明:
					//因为我们的i 从1开始的， 因此公式需要调整成
					//v[i][j]=Math.max(v[i-1][j], val[i-1]+v[i-1][j-w[i-1]]);
					//v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
					//为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else来体现公式
					if(v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
						v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
						//把当前的情况记录到path
						path[i][j] = 1;
					} else {
						v[i][j] = v[i - 1][j];
					}
					
				}
			}
		}
		
		//输出一下v 看看目前的情况
		for(int i =0; i < v.length;i++) {
			for(int j = 0; j < v[i].length;j++) {
				System.out.print(v[i][j] + " ");
			}
			System.out.println();
		}
		
		System.out.println("============================");
		//输出最后我们是放入的哪些商品
		//遍历path, 这样输出会把所有的放入情况都得到, 其实我们只需要最后的放入
//		for(int i = 0; i < path.length; i++) {
//			for(int j=0; j < path[i].length; j++) {
//				if(path[i][j] == 1) {
//					System.out.printf("第%d个商品放入到背包\n", i);
//				}
//			}
//		}
		
		//动脑筋
		int i = path.length - 1; //行的最大下标
		int j = path[0].length - 1;  //列的最大下标
		while(i > 0 && j > 0 ) { //从path的最后开始找
			if(path[i][j] == 1) {
				System.out.printf("第%d个商品放入到背包\n", i); 
				j -= w[i-1]; //w[i-1]
			}
			i--;
		}
		
	}

}

~~~



### 44.暴力匹配

~~~java

public class ViolenceMatch {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//测试暴力匹配算法
		String str1 = "硅硅谷 尚硅谷你尚硅 尚硅谷你尚硅谷你尚硅你好";
		String str2 = "尚硅谷你尚硅你~";
		int index = violenceMatch(str1, str2);
		System.out.println("index=" + index);

	}

	// 暴力匹配算法实现
	public static int violenceMatch(String str1, String str2) {
		char[] s1 = str1.toCharArray();
		char[] s2 = str2.toCharArray();

		int s1Len = s1.length;
		int s2Len = s2.length;

		int i = 0; // i索引指向s1
		int j = 0; // j索引指向s2
		while (i < s1Len && j < s2Len) {// 保证匹配时，不越界

			if(s1[i] == s2[j]) {//匹配ok
				i++;
				j++;
			} else { //没有匹配成功
				//如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。
				i = i - (j - 1);
				j = 0;
			}
		}
		
		//判断是否匹配成功
		if(j == s2Len) {
			return i - j;
		} else {
			return -1;
		}
	}

}

~~~



### 45.kmp算法

~~~java

import java.util.Arrays;

public class KMPAlgorithm {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String str1 = "BBC ABCDAB ABCDABCDABDE";
		String str2 = "ABCDABD";
		//String str2 = "BBC";
		
		int[] next = kmpNext("ABCDABD"); //[0, 1, 2, 0]
		System.out.println("next=" + Arrays.toString(next));
		
		int index = kmpSearch(str1, str2, next);
		System.out.println("index=" + index); // 15了
		
		
	}
	
	//写出我们的kmp搜索算法
	/**
	 * 
	 * @param str1 源字符串
	 * @param str2 子串
	 * @param next 部分匹配表, 是子串对应的部分匹配表
	 * @return 如果是-1就是没有匹配到，否则返回第一个匹配的位置
	 */
	public static int kmpSearch(String str1, String str2, int[] next) {
		
		//遍历 
		for(int i = 0, j = 0; i < str1.length(); i++) {
			
			//需要处理 str1.charAt(i) ！= str2.charAt(j), 去调整j的大小
			//KMP算法核心点, 可以验证...
			while( j > 0 && str1.charAt(i) != str2.charAt(j)) {
				j = next[j-1]; 
			}
			
			if(str1.charAt(i) == str2.charAt(j)) {
				j++;
			}			
			if(j == str2.length()) {//找到了 // j = 3 i 
				return i - j + 1;
			}
		}
		return  -1;
	}

	//获取到一个字符串(子串) 的部分匹配值表
	public static  int[] kmpNext(String dest) {
		//创建一个next 数组保存部分匹配值
		int[] next = new int[dest.length()];
		next[0] = 0; //如果字符串是长度为1 部分匹配值就是0
		for(int i = 1, j = 0; i < dest.length(); i++) {
			//当dest.charAt(i) != dest.charAt(j) ，我们需要从next[j-1]获取新的j
			//直到我们发现 有  dest.charAt(i) == dest.charAt(j)成立才退出
			//这时kmp算法的核心点
			while(j > 0 && dest.charAt(i) != dest.charAt(j)) {
				j = next[j-1];
			}
			
			//当dest.charAt(i) == dest.charAt(j) 满足时，部分匹配值就是+1
			if(dest.charAt(i) == dest.charAt(j)) {
				j++;
			}
			next[i] = j;
		}
		return next;
	}
}




~~~



### 46.贪心算法

~~~java

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class GreedyAlgorithm {

	public static void main(String[] args) {
		//创建广播电台,放入到Map
		HashMap<String,HashSet<String>> broadcasts = new HashMap<String, HashSet<String>>();
		//将各个电台放入到broadcasts
		HashSet<String> hashSet1 = new HashSet<String>();
		hashSet1.add("北京");
		hashSet1.add("上海");
		hashSet1.add("天津");
		
		HashSet<String> hashSet2 = new HashSet<String>();
		hashSet2.add("广州");
		hashSet2.add("北京");
		hashSet2.add("深圳");
		
		HashSet<String> hashSet3 = new HashSet<String>();
		hashSet3.add("成都");
		hashSet3.add("上海");
		hashSet3.add("杭州");
		
		
		HashSet<String> hashSet4 = new HashSet<String>();
		hashSet4.add("上海");
		hashSet4.add("天津");
		
		HashSet<String> hashSet5 = new HashSet<String>();
		hashSet5.add("杭州");
		hashSet5.add("大连");
	
		//加入到map
		broadcasts.put("K1", hashSet1);
		broadcasts.put("K2", hashSet2);
		broadcasts.put("K3", hashSet3);
		broadcasts.put("K4", hashSet4);
		broadcasts.put("K5", hashSet5);
		
		//allAreas 存放所有的地区
		HashSet<String> allAreas = new HashSet<String>();
		allAreas.add("北京");
		allAreas.add("上海");
		allAreas.add("天津");
		allAreas.add("广州");
		allAreas.add("深圳");
		allAreas.add("成都");
		allAreas.add("杭州");
		allAreas.add("大连");
		
		//创建ArrayList, 存放选择的电台集合
		ArrayList<String> selects = new ArrayList<String>();
		
		//定义一个临时的集合， 在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集
		HashSet<String> tempSet = new HashSet<String>();
		
		//定义给maxKey ， 保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key
		//如果maxKey 不为null , 则会加入到 selects
		String maxKey = null;
		while(allAreas.size() != 0) { // 如果allAreas 不为0, 则表示还没有覆盖到所有的地区
			//每进行一次while,需要
			maxKey = null;
			
			//遍历 broadcasts, 取出对应key
			for(String key : broadcasts.keySet()) {
				//每进行一次for
				tempSet.clear();
				//当前这个key能够覆盖的地区
				HashSet<String> areas = broadcasts.get(key);
				tempSet.addAll(areas);
				//求出tempSet 和   allAreas 集合的交集, 交集会赋给 tempSet
				tempSet.retainAll(allAreas);
				//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多
				//就需要重置maxKey
				// tempSet.size() >broadcasts.get(maxKey).size()) 体现出贪心算法的特点,每次都选择最优的
				if(tempSet.size() > 0 && 
						(maxKey == null || tempSet.size() >broadcasts.get(maxKey).size())){
					maxKey = key;
				}
			}
			//maxKey != null, 就应该将maxKey 加入selects
			if(maxKey != null) {
				selects.add(maxKey);
				//将maxKey指向的广播电台覆盖的地区，从 allAreas 去掉
				allAreas.removeAll(broadcasts.get(maxKey));
			}
			
		}
		
		System.out.println("得到的选择结果是" + selects);//[K1,K2,K3,K5]
		
		
		
	}

}

~~~

